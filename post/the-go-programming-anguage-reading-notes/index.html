<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta content="yes" name="apple-mobile-web-app-capable" />
<meta content="black" name="apple-mobile-web-app-status-bar-style" />
<meta name="referrer" content="never">
<meta name="keywords" content="">
<meta name="description" content="欢迎访问[Jinvic&#39;s Blog]的个人博客">
<meta name="author" content="kveln">
<title>《Go程序设计语言》阅读笔记 | Jinvic&#39;s Blog</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">
<link href="https://cdn.bootcss.com/font-awesome/5.11.2/css/all.min.css" rel="stylesheet">
<link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
<link
  href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800'
  rel='stylesheet' type='text/css'>
<link rel="alternate" type="application/rss+xml" title="《Go程序设计语言》阅读笔记 | Jinvic&#39;s Blog » Feed"
  href="https://jinvic.github.io/atom.xml">
<link rel="stylesheet"
  href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.15.10/build/styles/androidstudio.min.css">
<link href="https://jinvic.github.io/styles/main.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/850552586/ericamcdn@0.1/css/live2d.css">

<script>hljs.initHighlightingOnLoad();</script>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-YCF6X0GKYH"></script>
<script>window.dataLayer = window.dataLayer || [];
    function gtag() {
      dataLayer.push(arguments)
    }
    gtag('js', new Date());
    gtag('config', 'G-YCF6X0GKYH');</script>

  <meta property="og:description" content="《Go程序设计语言》阅读笔记" />
  <meta property="og:url" content="https://jinvic.github.io/post/the-go-programming-anguage-reading-notes/" />
  <meta property="og:locale" content="zh-CN" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="Jinvic&#39;s Blog" />
  <!-- <script src="../assets/styles/scripts/tocScript.js"></script> -->
</head>

<body>
  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://jinvic.github.io">Jinvic&#39;s Blog</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="/">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/post/about">关于</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1750747815360"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
  <!-- Page Header -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://jinvic.github.io">Jinvic&#39;s Blog</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="/">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/post/about">关于</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1750747815360"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
<header class="masthead" style="background-image: url('https://jinvic.github.io/media/images/home-bg.jpg')">
  <div class="overlay"></div>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        
          <!-- 没Title为其他页面Header -->
          
            <!-- 没Title并且有headerType为Post：文章Header -->
            <div class="post-heading">
              <span class="tags">
                
                <a href="https://jinvic.github.io/tag/2vaencnsMM/" class="tag">Go</a>
                
                <a href="https://jinvic.github.io/tag/KbkCyWeWckl/" class="tag">笔记</a>
                
              </span>
              <h1>《Go程序设计语言》阅读笔记</h1>
              <span class="meta">
                Posted on
                2024-08-15，55 min read
              </span>
            </div>
          
        
      </div>
    </div>
  </div>
</header>
  <!-- Post Content -->
  <article id="post-content-article">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto post-content-container">
          
          <h1 id="go程序设计语言阅读笔记">《Go程序设计语言》阅读笔记</h1>
<p><ul class="markdownIt-TOC">
<li><a href="#go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0">《Go程序设计语言》阅读笔记</a>
<ul>
<li><a href="#%E7%AC%AC1%E7%AB%A0-%E5%85%A5%E9%97%A8">第1章 入门</a></li>
<li><a href="#%E7%AC%AC2%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84">第2章 程序结构</a>
<ul>
<li><a href="#21-%E5%90%8D%E7%A7%B0">2.1 名称</a></li>
<li><a href="#22-%E5%A3%B0%E6%98%8E">2.2 声明</a></li>
<li><a href="#23-%E5%8F%98%E9%87%8F">2.3 变量</a>
<ul>
<li><a href="#231-%E7%9F%AD%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E">2.3.1 短变量声明</a></li>
<li><a href="#232-%E6%8C%87%E9%92%88">2.3.2 指针</a></li>
<li><a href="#233-new-%E5%87%BD%E6%95%B0">2.3.3 new 函数</a></li>
<li><a href="#234-%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">2.3.4 变量的生命周期</a></li>
</ul>
</li>
<li><a href="#24-%E8%B5%8B%E5%80%BC">2.4 赋值</a>
<ul>
<li><a href="#241-%E5%A4%9A%E9%87%8D%E8%B5%8B%E5%80%BC">2.4.1 多重赋值</a></li>
<li><a href="#242-%E5%8F%AF%E8%B5%8B%E5%80%BC%E6%80%A7">2.4.2 可赋值性</a></li>
</ul>
</li>
<li><a href="#25-%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E">2.5 类型声明</a></li>
<li><a href="#26-%E5%8C%85%E5%92%8C%E6%96%87%E4%BB%B6">2.6 包和文件</a></li>
<li><a href="#27-%E4%BD%9C%E7%94%A8%E5%9F%9F">2.7 作用域</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC3%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE">第3章 基本数据</a>
<ul>
<li><a href="#31-%E6%95%B4%E6%95%B0">3.1 整数</a></li>
<li><a href="#32-%E6%B5%AE%E7%82%B9%E6%95%B0">3.2 浮点数</a></li>
<li><a href="#33-%E5%A4%8D%E6%95%B0">3.3 复数</a></li>
<li><a href="#34-%E5%B8%83%E5%B0%94%E5%80%BC">3.4 布尔值</a></li>
<li><a href="#35-%E5%AD%97%E7%AC%A6%E4%B8%B2">3.5 字符串</a>
<ul>
<li><a href="#351-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F">3.5.1 字符串字面量</a></li>
<li><a href="#352-unicode">3.5.2 Unicode</a></li>
<li><a href="#353-utf-8">3.5.3 UTF-8</a></li>
<li><a href="#354-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E8%8A%82-slice">3.5.4 字符串和字节 slice</a></li>
<li><a href="#355-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E5%AD%97%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2">3.5.5 字符串和数字的相互转换</a></li>
</ul>
</li>
<li><a href="#36-%E5%B8%B8%E9%87%8F">3.6 常量</a>
<ul>
<li><a href="#361-%E5%B8%B8%E9%87%8F%E7%94%9F%E6%88%90%E5%99%A8-iota">3.6.1 常量生成器 iota</a></li>
<li><a href="#362-%E6%97%A0%E7%B1%BB%E5%9E%8B%E5%B8%B8%E9%87%8F">3.6.2 无类型常量</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%AC%AC4%E7%AB%A0-%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">第4章 复合数据类型</a>
<ul>
<li><a href="#41-%E6%95%B0%E7%BB%84">4.1 数组</a></li>
<li><a href="#42-slice">4.2 slice</a>
<ul>
<li><a href="#421-append-%E5%87%BD%E6%95%B0">4.2.1 append 函数</a></li>
<li><a href="#422-slice-%E5%B0%B1%E5%9C%B0%E4%BF%AE%E6%94%B9">4.2.2 slice 就地修改</a></li>
</ul>
</li>
<li><a href="#43-map">4.3 map</a></li>
<li><a href="#44-%E7%BB%93%E6%9E%84%E4%BD%93">4.4 结构体</a>
<ul>
<li><a href="#441-%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E9%9D%A2%E9%87%8F">4.4.1 结构体字面量</a></li>
<li><a href="#442-%E7%BB%93%E6%9E%84%E4%BD%93%E6%AF%94%E8%BE%83">4.4.2 结构体比较</a></li>
<li><a href="#443-%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%A5%97%E5%92%8C%E5%8C%BF%E5%90%8D%E6%88%90%E5%91%98">4.4.3 结构体嵌套和匿名成员</a></li>
</ul>
</li>
<li><a href="#45-json">4.5 JSON</a></li>
<li><a href="#46-%E6%96%87%E6%9C%AC%E5%92%8Chtml%E6%A8%A1%E6%9D%BF">4.6 文本和HTML模板</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC5%E7%AB%A0-%E5%87%BD%E6%95%B0">第5章 函数</a>
<ul>
<li><a href="#51-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E">5.1 函数声明</a></li>
<li><a href="#52-%E9%80%92%E5%BD%92">5.2 递归</a></li>
<li><a href="#53-%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC">5.3 多返回值</a></li>
<li><a href="#54-%E9%94%99%E8%AF%AF">5.4 错误</a>
<ul>
<li><a href="#541-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5">5.4.1 错误处理策略</a></li>
<li><a href="#542-%E6%96%87%E4%BB%B6%E7%BB%93%E6%9D%9F%E6%A0%87%E8%AF%86">5.4.2 文件结束标识</a></li>
</ul>
</li>
<li><a href="#55-%E5%87%BD%E6%95%B0%E5%8F%98%E9%87%8F">5.5 函数变量</a></li>
<li><a href="#56-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0">5.6 匿名函数</a></li>
<li><a href="#57-%E5%8F%98%E9%95%BF%E5%87%BD%E6%95%B0">5.7 变长函数</a></li>
<li><a href="#58-%E5%BB%B6%E8%BF%9F%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">5.8 延迟函数调用</a></li>
<li><a href="#59-%E5%AE%95%E6%9C%BA">5.9 宕机</a></li>
<li><a href="#510-%E6%81%A2%E5%A4%8D">5.10 恢复</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC6%E7%AB%A0-%E6%96%B9%E6%B3%95">第6章 方法</a>
<ul>
<li><a href="#61-%E6%96%B9%E6%B3%95%E5%A3%B0%E6%98%8E">6.1 方法声明</a></li>
<li><a href="#62-%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85%E7%9A%84%E6%96%B9%E6%B3%95">6.2 指针接收者的方法</a></li>
<li><a href="#63-%E9%80%9A%E8%BF%87%E6%8E%A5%E5%8F%A3%E6%8F%90%E5%86%85%E5%B5%8C%E7%BB%84%E6%88%90%E7%B1%BB%E5%9E%8B">6.3 通过接口提内嵌组成类型</a></li>
<li><a href="#64-%E6%96%B9%E6%B3%95%E5%8F%98%E9%87%8F%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F">6.4 方法变量与表达式</a></li>
<li><a href="#65-%E7%A4%BA%E4%BE%8B%E4%BD%8D%E5%90%91%E9%87%8F">6.5 示例：位向量</a></li>
<li><a href="#66-%E5%B0%81%E8%A3%85">6.6 封装</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC7%E7%AB%A0-%E6%8E%A5%E5%8F%A3">第7章 接口</a>
<ul>
<li><a href="#71-%E6%8E%A5%E5%8F%A3%E5%8D%B3%E7%BA%A6%E5%AE%9A">7.1 接口即约定</a></li>
<li><a href="#72-%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B">7.2 接口类型</a></li>
<li><a href="#73-%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3">7.3 实现接口</a></li>
<li><a href="#74-%E4%BD%BF%E7%94%A8-flagvalue-%E6%9D%A5%E8%A7%A3%E6%9E%90%E5%8F%82%E6%95%B0">7.4 使用 flag.Value 来解析参数</a></li>
<li><a href="#75-%E6%8E%A5%E5%8F%A3%E5%80%BC">7.5 接口值</a></li>
<li><a href="#76-%E4%BD%BF%E7%94%A8-sortinterface-%E6%9D%A5%E6%8E%92%E5%BA%8F">7.6 使用 sort.Interface 来排序</a></li>
<li><a href="#77-httphandler-%E6%8E%A5%E5%8F%A3">7.7 http.Handler 接口</a></li>
<li><a href="#78-error-%E6%8E%A5%E5%8F%A3">7.8 error 接口</a></li>
<li><a href="#79-%E7%A4%BA%E4%BE%8B%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E5%99%A8">7.9 示例：表达式求值器</a></li>
<li><a href="#710-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80">7.10 类型断言</a></li>
<li><a href="#711-%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E6%9D%A5%E8%AF%86%E5%88%AB%E9%94%99%E8%AF%AF">7.11 使用类型断言来识别错误</a></li>
<li><a href="#712-%E9%80%9A%E8%BF%87%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E6%9D%A5%E6%9F%A5%E8%AF%A2%E7%89%B9%E6%80%A7">7.12 通过接口类型断言来查询特性</a></li>
<li><a href="#713-%E7%B1%BB%E5%9E%8B%E5%88%86%E6%94%AF">7.13 类型分支</a></li>
<li><a href="#714-%E7%A4%BA%E4%BE%8B%E5%9F%BA%E4%BA%8E%E6%A0%87%E8%AE%B0%E7%9A%84xml%E8%A7%A3%E6%9E%90">7.14 示例：基于标记的XML解析</a></li>
<li><a href="#715-%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE">7.15 一些建议</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC8%E7%AB%A0-goroutine%E5%92%8C%E9%80%9A%E9%81%93">第8章 goroutine和通道</a>
<ul>
<li><a href="#81-goroutine">8.1 goroutine</a></li>
<li><a href="#82-%E7%A4%BA%E4%BE%8B%E5%B9%B6%E5%8F%91%E6%97%B6%E9%92%9F%E6%9C%8D%E5%8A%A1%E5%99%A8">8.2 示例：并发时钟服务器</a></li>
<li><a href="#83-%E7%A4%BA%E4%BE%8B%E5%B9%B6%E5%8F%91%E5%9B%9E%E5%A3%B0%E6%9C%8D%E5%8A%A1%E5%99%A8">8.3 示例：并发回声服务器</a></li>
<li><a href="#84-%E9%80%9A%E9%81%93">8.4 通道</a>
<ul>
<li><a href="#841-%E6%97%A0%E7%BC%93%E5%86%B2%E9%80%9A%E9%81%93">8.4.1 无缓冲通道</a></li>
<li><a href="#842-%E7%AE%A1%E9%81%93">8.4.2 管道</a></li>
<li><a href="#843-%E5%8D%95%E5%90%91%E9%80%9A%E9%81%93%E7%B1%BB%E5%9E%8B">8.4.3 单向通道类型</a></li>
<li><a href="#844-%E7%BC%93%E5%86%B2%E9%80%9A%E9%81%93">8.4.4 缓冲通道</a></li>
</ul>
</li>
<li><a href="#85-%E5%B9%B6%E8%A1%8C%E5%BE%AA%E7%8E%AF">8.5 并行循环</a></li>
<li><a href="#86-%E7%A4%BA%E4%BE%8B%E5%B9%B6%E5%8F%91%E7%9A%84web%E7%88%AC%E8%99%AB">8.6 示例：并发的Web爬虫</a></li>
<li><a href="#87-%E4%BD%BF%E7%94%A8select%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">8.7 使用select多路复用</a></li>
<li><a href="#88-%E7%A4%BA%E4%BE%8B%E5%B9%B6%E5%8F%91%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86">8.8 示例：并发目录遍历</a></li>
<li><a href="#89-%E5%8F%96%E6%B6%88">8.9 取消</a></li>
<li><a href="#810-%E7%A4%BA%E4%BE%8B%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8">8.10 示例：聊天服务器</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC9%E7%AB%A0-%E4%BD%BF%E7%94%A8%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91">第9章 使用共享变量实现并发</a>
<ul>
<li><a href="#91-%E7%AB%9E%E6%80%81">9.1 竞态</a></li>
<li><a href="#92-%E4%BA%92%E6%96%A5%E9%94%81-syncmutex">9.2 互斥锁 sync.Mutex</a></li>
<li><a href="#93-%E8%AF%BB%E5%86%99%E4%BA%92%E6%96%A5%E9%94%81syncrwmutex">9.3 读写互斥锁：sync.RWMutex</a></li>
<li><a href="#94-%E5%86%85%E5%AD%98%E5%90%8C%E6%AD%A5">9.4 内存同步</a></li>
<li><a href="#95-%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E5%8C%96synconce">9.5 延迟初始化：sync.Once</a></li>
<li><a href="#96-%E7%AB%9E%E6%80%81%E6%A3%80%E6%B5%8B%E5%99%A8">9.6 竞态检测器</a></li>
<li><a href="#97-%E7%A4%BA%E4%BE%8B%E5%B9%B6%E5%8F%91%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%BC%93%E5%AD%98">9.7 示例：并发非阻塞缓存</a></li>
<li><a href="#98-goroutine-%E4%B8%8E%E7%BA%BF%E7%A8%8B">9.8 goroutine 与线程</a>
<ul>
<li><a href="#981-%E5%8F%AF%E5%A2%9E%E9%95%BF%E7%9A%84%E6%A0%88">9.8.1 可增长的栈</a></li>
<li><a href="#982-goroutine-%E8%B0%83%E5%BA%A6">9.8.2 goroutine 调度</a></li>
<li><a href="#983-gomaxprocs">9.8.3 GOMAXPROCS</a></li>
<li><a href="#984-goroutine-%E6%B2%A1%E6%9C%89%E6%A0%87%E8%AF%86">9.8.4 goroutine 没有标识</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%AC%AC10%E7%AB%A0-%E5%8C%85%E5%92%8C-go-%E5%B7%A5%E5%85%B7">第10章 包和 go 工具</a>
<ul>
<li><a href="#101-%E5%BC%95%E8%A8%80">10.1 引言</a></li>
<li><a href="#102-%E5%AF%BC%E5%85%A5%E8%B7%AF%E5%BE%84">10.2 导入路径</a></li>
<li><a href="#103-%E5%8C%85%E7%9A%84%E5%A3%B0%E6%98%8E">10.3 包的声明</a></li>
<li><a href="#104-%E5%AF%BC%E5%85%A5%E5%A3%B0%E6%98%8E">10.4 导入声明</a></li>
<li><a href="#105-%E7%A9%BA%E5%AF%BC%E5%85%A5">10.5 空导入</a></li>
<li><a href="#106-%E5%8C%85%E5%8F%8A%E5%85%B6%E5%91%BD%E5%90%8D">10.6 包及其命名</a></li>
<li><a href="#107-go-%E5%B7%A5%E5%85%B7">10.7 go 工具</a>
<ul>
<li><a href="#1071-%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E7%9A%84%E7%BB%84%E7%BB%87">10.7.1 工作空间的组织</a></li>
<li><a href="#1072-%E5%8C%85%E7%9A%84%E4%B8%8B%E8%BD%BD">10.7.2 包的下载</a></li>
<li><a href="#1073-%E5%8C%85%E7%9A%84%E6%9E%84%E5%BB%BA">10.7.3 包的构建</a></li>
<li><a href="#1074-%E5%8C%85%E7%9A%84%E6%96%87%E6%A1%A3%E5%8C%96">10.7.4 包的文档化</a></li>
<li><a href="#1075-%E5%86%85%E9%83%A8%E5%8C%85">10.7.5 内部包</a></li>
<li><a href="#1076-%E5%8C%85%E7%9A%84%E6%9F%A5%E8%AF%A2">10.7.6 包的查询</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%AC%AC11%E7%AB%A0-%E6%B5%8B%E8%AF%95">第11章 测试</a>
<ul>
<li><a href="#111-go-test-%E5%B7%A5%E5%85%B7">11.1 go test 工具</a></li>
<li><a href="#112-test-%E5%87%BD%E6%95%B0">11.2 Test 函数</a>
<ul>
<li><a href="#1121-%E9%9A%8F%E6%9C%BA%E6%B5%8B%E8%AF%95">11.2.1 随机测试</a></li>
<li><a href="#1122-%E6%B5%8B%E8%AF%95%E5%91%BD%E4%BB%A4">11.2.2 测试命令</a></li>
<li><a href="#1123-%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95">11.2.3 白盒测试</a></li>
<li><a href="#1124-%E5%A4%96%E9%83%A8%E6%B5%8B%E8%AF%95%E5%8C%85">11.2.4 外部测试包</a></li>
<li><a href="#1125-%E7%BC%96%E5%86%99%E6%9C%89%E6%95%88%E6%B5%8B%E8%AF%95">11.2.5 编写有效测试</a></li>
<li><a href="#1126-%E9%81%BF%E5%85%8D%E8%84%86%E5%BC%B1%E7%9A%84%E6%B5%8B%E8%AF%95">11.2.6 避免脆弱的测试</a></li>
</ul>
</li>
<li><a href="#113-%E8%A6%86%E7%9B%96%E7%8E%87">11.3 覆盖率</a></li>
<li><a href="#114-benchmark-%E5%87%BD%E6%95%B0">11.4 Benchmark 函数</a></li>
<li><a href="#115-%E6%80%A7%E8%83%BD%E5%88%A8%E6%9E%90">11.5 性能刨析</a></li>
<li><a href="#116-example-%E5%87%BD%E6%95%B0">11.6 Example 函数</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC12%E7%AB%A0-%E5%8F%8D%E5%B0%84">第12章 反射</a>
<ul>
<li><a href="#121-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84">12.1 为什么使用反射</a></li>
<li><a href="#122-reflecttype-%E5%92%8C-reflectvalue">12.2 reflect.Type 和 reflect.Value</a></li>
<li><a href="#123-display-%E4%B8%80%E4%B8%AA%E9%80%92%E5%BD%92%E7%9A%84%E5%80%BC%E6%98%BE%E7%A4%BA%E5%99%A8">12.3 Display: 一个递归的值显示器</a></li>
<li><a href="#124-%E7%A4%BA%E4%BE%8B-%E7%BC%96%E7%A0%81s%E8%A1%A8%E8%BE%BE%E5%BC%8F">12.4 示例: 编码S表达式</a></li>
<li><a href="#125-%E4%BD%BF%E7%94%A8-reflectvalue-%E6%9D%A5%E8%AE%BE%E7%BD%AE%E5%80%BC">12.5 使用 reflect.Value 来设置值</a></li>
<li><a href="#126-%E7%A4%BA%E4%BE%8B%E8%A7%A3%E7%A0%81s%E8%A1%A8%E8%BE%BE%E5%BC%8F">12.6 示例：解码S表达式</a></li>
<li><a href="#127-%E8%AE%BF%E9%97%AE%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E6%AE%B5%E6%A0%87%E7%AD%BE">12.7 访问结构体字段标签</a></li>
<li><a href="#128-%E6%98%BE%E7%A4%BA%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95">12.8 显示类型的方法</a></li>
<li><a href="#129-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">12.9 注意事项</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC13%E7%AB%A0-%E4%BD%8E%E7%BA%A7%E7%BC%96%E7%A8%8B">第13章 低级编程</a>
<ul>
<li><a href="#131-unsafesizeof-alignof-%E5%92%8C-offsetof">13.1 unsafe.Sizeof、Alignof 和 Offsetof</a></li>
<li><a href="#132-unsafepointer">13.2 unsafe.Pointer</a></li>
<li><a href="#133-%E7%A4%BA%E4%BE%8B%E6%B7%B1%E5%BA%A6%E7%9B%B8%E7%AD%89">13.3 示例：深度相等</a></li>
<li><a href="#134-%E4%BD%BF%E7%94%A8cgo%E8%B0%83%E7%94%A8c%E4%BB%A3%E7%A0%81">13.4 使用cgo调用C代码</a></li>
<li><a href="#135-%E5%85%B3%E4%BA%8E%E5%AE%89%E5%85%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">13.5 关于安全的注意事项</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h2 id="第1章-入门">第1章 入门</h2>
<p>给几个例子快速讲解go语言的结构例子，如果是对go比较熟悉的读者或许会比较方便。但我是从零开始，对我而言跳跃得有些太快了，看到1.4就跟不上了。不过也没关系，从第二章开始看更详细更系统化。</p>
<h2 id="第2章-程序结构">第2章 程序结构</h2>
<h3 id="21-名称">2.1 名称</h3>
<p>给出Go语言中的<strong>关键字</strong>和<strong>预声明</strong>的常量、类型和函数，有需要可以查表。</p>
<ul>
<li><strong>命名规则</strong></li>
</ul>
<p>一般使用<strong>驼峰式</strong>，首字母缩写使用相同大小写。</p>
<h3 id="22-声明">2.2 声明</h3>
<p>没啥内容，重要的都放在后续章节详细展开。</p>
<h3 id="23-变量">2.3 变量</h3>
<p>变量声明通用形式：<code>var name = expression</code></p>
<p>类型和表达式可以省略其一。如果省略类型，将由表达式自动推断；如果省略表达式，初始值为对应类型的零值。</p>
<h4 id="231-短变量声明">2.3.1 短变量声明</h4>
<p><code>name := expresion</code></p>
<ul>
<li>短小灵活，常用于局部变量的声明和初始化</li>
<li>不需要声明所有变量，对已声明变量相当于赋值</li>
<li>最少声明一个新变量</li>
</ul>
<h4 id="232-指针">2.3.2 指针</h4>
<p>基本用法和C一致，使用<code>&amp;</code>取地址，<code>*</code>解引用。</p>
<p>简单介绍了<code>flag</code>包的用法来辅助说明指针。</p>
<h4 id="233-new-函数">2.3.3 new 函数</h4>
<p>表达式<code>new(T)</code>将创建一个<strong>未命名</strong>的T类型变量，初始化为该类型的零值，并返回其地址。简单来说，就是方便快捷地获取某一类型的地址，而不必先声明再取地址。</p>
<p><code>new</code>是一个预声明的函数，不是关键字，可以被重定义。</p>
<h4 id="234-变量的生命周期">2.3.4 变量的生命周期</h4>
<p>生命周期的概念很多编程语言都有，不用再看一遍。</p>
<p>这部分还提到了垃圾回收和变量逃逸的概念，不过也是浅尝辄止，不看也行。</p>
<h3 id="24-赋值">2.4 赋值</h3>
<p>Go和C++类似有着形如<code>+=</code>这样的运算赋值和<code>++</code>,<code>--</code>这样的自增自减运算。</p>
<h4 id="241-多重赋值">2.4.1 多重赋值</h4>
<p>和Python类似，Go也可以同时为复数变量赋值，并可以将不需要的值赋给空标识符<code>_</code>。</p>
<h4 id="242-可赋值性">2.4.2 可赋值性</h4>
<p>没看懂在讲什么，但是不重要。</p>
<h3 id="25-类型声明">2.5 类型声明</h3>
<p><code>type name underlying-type</code></p>
<p>和C++的<code>typedef</code>类似，Go也可以通过<code>type</code>关键字为某一类型设置一个别名，方便阅读理解和使用。但不同的是，Go使用<code>type</code>定义的命名类型，即使底层类型相同也不能使用算术表达式进行比较和合并，主要是为了<strong>避免混用</strong>。</p>
<p>这部分还提了下类型声明在接口中的使用方法，这将在第七章详细说明。</p>
<h3 id="26-包和文件">2.6 包和文件</h3>
<ul>
<li>
<p><strong>可见性</strong></p>
</li>
<li>
<p>声明在函数内部，是函数的本地值，类似private</p>
</li>
<li>
<p>声明在函数外部，是对当前包可见(包内所有.go文件都可见)的全局值，类似protect</p>
</li>
<li>
<p>声明在函数外部且首字母大写是所有包可见的全局值,类似public</p>
</li>
</ul>
<h3 id="27-作用域">2.7 作用域</h3>
<p>大部分内容都不难理解。只是有一个地方需要注意一下：<strong>短变量声明依赖一个明确的作用域</strong>。错误示例：</p>
<pre><code class="language-Go">var x int = 0
if true {
    x, y := 1, 2
    fmt.Println(x, y)
}
x += x
fmt.Println(x)
//1，2
//0
</code></pre>
<p>在如上代码中，x,y在内部作用域都为声明，短变量声明<code>:=</code>将会将x,y都声明为内部的局部变量，使外部的x声明不可见，从而未能成功变更外部x的值。这是一个很隐蔽的错误，甚至不会报错。</p>
<p>要避免这个错误，可以放弃使用短变量声明而是先声明再直接赋值：</p>
<pre><code class="language-Go">var x int = 0
if true {
    var y int
    x, y = 1, 2
    fmt.Println(x, y)
}
x += x
fmt.Println(x)
//1，2
//2
</code></pre>
<h2 id="第3章-基本数据">第3章 基本数据</h2>
<p>Go四类数据类型：基础类型（basic type），聚合类型（aggregate type），引用类型(reference type)，接口类型（interface type）。</p>
<h3 id="31-整数">3.1 整数</h3>
<p>数据类型和C中的stdint.h类似，对不同位数的int进行了精确划分，这里记几个比较特殊的。</p>
<ul>
<li><code>rune</code>和<code>int32</code>同意，指明一个值是Unicode码点（code point）。</li>
<li><code>byte</code>和<code>uint8</code>同意，强调一个值是原始数据而非量值。</li>
<li><code>uintptr</code>大小不定，完整存放指针，用于底层编程。</li>
</ul>
<p>这部分还介绍了算数运算符，逻辑运算符和位运算符以及他们之间的优先级，有需要可以查表。</p>
<p>位运算符和C稍有不同，记一下。</p>
<ul>
<li><code>^</code>作为二元运算符表示按位“异或”(XOR)，如果需要写次方可以用<code>math.Pow()</code>。作为一元运算符表示取反。</li>
<li><code>&amp;^</code>表示按位清除（AND NOT），如表达式z=x&amp;^y中，若y的某位是1,则z的对应位等于0;否则，它就等于x的对应位。</li>
</ul>
<p>格式化输出八进制<code>%o</code>，十六进制<code>%x</code>时，前面的副词<code>#</code>告知是否输出相应前缀<code>0</code>，<code>0x</code>。</p>
<h3 id="32-浮点数">3.2 浮点数</h3>
<p>格式化输出浮点数时，<code>%g</code>会自动保持足够的精度，<code>%e</code>（有指数）<code>%f</code>（无指数）能自定义输出宽度和数值精度。</p>
<h3 id="33-复数">3.3 复数</h3>
<p>GO居然还有复数类型，但感觉我用不上就没怎么看，应该科学计算或者图形学会用的多些。</p>
<h3 id="34-布尔值">3.4 布尔值</h3>
<p>唯一需要注意的是Go中整数不能像C那样直接当布尔值用需要显性转换。</p>
<h3 id="35-字符串">3.5 字符串</h3>
<p>和python类似，没啥新东西。</p>
<h4 id="351-字符串字面量">3.5.1 字符串字面量</h4>
<p>介绍了一些转义符，可以查表。</p>
<ul>
<li>
<p><strong>字符串字面量</strong>使用双引号，可以转义。</p>
</li>
<li>
<p><strong>原生的字符串字面量</strong>使用反引号，不能转义，可以展开多行。</p>
</li>
</ul>
<h4 id="352-unicode">3.5.2 Unicode</h4>
<p>介绍Unicode来源和<code>rune</code>。</p>
<h4 id="353-utf-8">3.5.3 UTF-8</h4>
<p>略，有需要再翻书。</p>
<h4 id="354-字符串和字节-slice">3.5.4 字符串和字节 slice</h4>
<p>比较了字符串和slice，因为不熟悉slice没看出什么重点，有空回头补。</p>
<h4 id="355-字符串和数字的相互转换">3.5.5 字符串和数字的相互转换</h4>
<p>略，有需要再翻书。该加速了，少扣点细节。</p>
<h3 id="36-常量">3.6 常量</h3>
<p>同时声明一组常量时，可以省略第一项以外的表达式，这时会复用前一项的表达式及类型。</p>
<h4 id="361-常量生成器-iota">3.6.1 常量生成器 iota</h4>
<p><code>iota</code>从0开始取值逐项加1。复数声明常量时由于复用表达式可以达到不同初始值的效果。具体实例见书。</p>
<h4 id="362-无类型常量">3.6.2 无类型常量</h4>
<p>略，有需要再翻书。</p>
<h2 id="第4章-复合数据类型">第4章 复合数据类型</h2>
<h3 id="41-数组">4.1 数组</h3>
<p>大部分都是基础知识，有一些比较新奇的定义方法：</p>
<ul>
<li>使用<code>...</code>代替数组长度，数组长度将有初始化时的元素个数决定，如<code>arr := [...]int{1,2,3}</code>长度为3。</li>
<li>初始化时可以使用<code>pos:value</code>仅定义部分元素，未定义的元素默认为零值。如<code>arr := [...]int{4:1}</code>，即为{0,0,0,0,1}。</li>
</ul>
<p>在如C等编程语言中，数组都是隐式的引用传递，而在Go中，直接传递数组当参将会和其他类型一样使用<strong>值传递</strong>，创建一个副本。此外，数组的大小也是其类型的一部分，类型 [10]int 和 [20]int 是不同的。</p>
<h3 id="42-slice">4.2 slice</h3>
<p>slice的大部分操作都和数组类似，主要是长度不定，概念和用法更接近c的vector和python的list。slice的零值是nil。slice也可以通过<code>make([]T, len, cap)</code>来声明，其中容量可省略。</p>
<p>slice和数组的区别首先是定义式slice不需要指定长度。然后是数组可以直接比较而slice不可以，需要手写比较函数。</p>
<h4 id="421-append-函数">4.2.1 append 函数</h4>
<p>在讲什么没找到重点。可能是想让读者注意一下len和cap吧，但这个基本上都是隐性的用的时候真不用想真么多。</p>
<h4 id="422-slice-就地修改">4.2.2 slice 就地修改</h4>
<p>介绍一些slice的精细操作，还是感觉没大用。</p>
<h3 id="43-map">4.3 map</h3>
<p>记一下定义方式：<code>ages := make(map[string]int)</code></p>
<p>可以使用<code>{key:value,...}</code>初始化，以及<code>delete(key,value)</code>删除元素。</p>
<p>map和slice都是引用，不能直接获取地址，可以用range遍历，将返回键值对。</p>
<p>map中元素迭代顺序不固定，一般认为是随机的，可以是程序在不同散列算法实现下变得健壮。如需按顺序遍历，必须显式地给键排序。</p>
<p>map类型的零值是<code>nil</code>，大多数map操作都可以在零值nil上执行，但设置元素会导致错误，必须先初始化map。</p>
<p>可以通过<code>if value, ok := m[key]; !ok</code>来判断这个元素是不存在还是零值。</p>
<p>map需求特殊数据类型作为键（如slice），可以定义一个帮助函数中转，将不可比较的数据类型映射到字符串。示例如下：</p>
<pre><code class="language-go">var m make(map[string]int)
func k(list []string) string { return fmt.Sprintf(&quot;%q&quot;, list) }
func Add(list []string) { m[k(list)]++ }
func Count(list []string) { return m[k(list)] }
</code></pre>
<h3 id="44-结构体">4.4 结构体</h3>
<p>定义：</p>
<pre><code class="language-go">type struct1 struct{
    field1 type1
    field2 type2
    struct2 // 嵌入结构体，继承所有字段 Embedded
    struct3 struct3 // 嵌套结构体，通过.访问子结构体字段 Nested
}
</code></pre>
<p>结构体定义时不能定义一个相同结构体类型的成员变量（对其他聚合类型也适用），但可以定义一个指向该类型的指针，从而实现递归数据结构，比如链表和树。</p>
<p>结构体零值由成员零值组成。</p>
<p>没有成员变量的结构体为<strong>空结构体</strong>，写作<code>struct{}</code>。这里没有过多介绍空结构体，作者似乎也不提倡这么用。</p>
<h4 id="441-结构体字面量">4.4.1 结构体字面量</h4>
<p>可以通过<strong>结构体字面量</strong>，即设置结构体成员变量来设置结构体的值。有两种格式，两种方法不能混用：</p>
<ul>
<li>按顺序为<em>每个</em>成员变量赋值<br>
可读性差，仅用于顺序明显的小结构体</li>
<li>指定成员变量名称和值<br>
不需要按顺序，可以仅赋值部分成员</li>
</ul>
<p>关于结构体指针的使用和c类似，不再赘述。</p>
<h4 id="442-结构体比较">4.4.2 结构体比较</h4>
<h4 id="443-结构体嵌套和匿名成员">4.4.3 结构体嵌套和匿名成员</h4>
<p>关于这部分内容我最早还是再gorm里看到的。那边把两种情况分开，分别叫嵌套（Nested）和嵌入（Embedded），这边都叫嵌套，然后匿名作为一种特殊用法。</p>
<pre><code class="language-go">type Point struct {X,Y int}
type Circle struct {Point; Radius int}
type Wheel struct {Circle; Spokes int}
</code></pre>
<p>这时就可以直接访问需要变量而省略中间变量，即匿名成员：</p>
<pre><code class="language-go">var w Whell
w.x = 1 // 两种用法等价
W.Circle.Point.y = 1
</code></pre>
<p>但是使用结构体字面量初始化并不能省略，需要遵循定义：</p>
<pre><code class="language-go">var w1, w2 Wheel
w1 = Wheel{Circle{Point{1,2},3},4}
w2 = Wheel{
    Circle : Circle{
        Point : Point{
            X : 1,
            y : 2,
        },
        Radius : 3,
    },
    Spoke : 4,
}
</code></pre>
<h3 id="45-json">4.5 JSON</h3>
<p>json格式略。</p>
<p><strong>Go数据结构转换为JSON</strong>:</p>
<p><code>json.marshal(v any)</code><br>
返回一个不带任何多余空白字符的很长的字符串。<br>
<code>json.marshalIndent(v any,prefix string,indent string)</code><br>
输出格式化结果，prefix为前缀，indent为缩进。</p>
<p>只有可导出的成员才能转换为json。<br>
可以使用 <em>成员标签定义</em> 更改转换为json后的字段名，如<code>json:fieldname</code>。</p>
<p><strong>JSON解析为Go数据结构</strong>：</p>
<p><code>json.unmarshal(data []byte, v any)</code><br>
jsong字段关联到结构体成员时忽略大小写，但存在下划线的话还是要用标签定义。</p>
<p>流式解码器<code>json.Decoder</code>,使用示例：</p>
<pre><code class="language-go">terms := []string{&quot;...&quot;}
q := url.QueryEscape(string.Join(terms, &quot; &quot;))
resp, err := http.Get(URL + &quot;?q=&quot; + q)
defer resp.Body.Close()
json.NewDecoder(resp.body).decode(&amp;result)
</code></pre>
<h3 id="46-文本和html模板">4.6 文本和HTML模板</h3>
<blockquote>
<p>模板是一个字符串或者文件，它包含一个或者多个两边用双大括号包围的单元<br>
<code>{{...}}</code>，这称为<strong>操作</strong>。</p>
</blockquote>
<p>操作提供的功能：</p>
<ul>
<li>输出值</li>
<li>选择结构体成员</li>
<li>调用函数和方法</li>
<li>描述控制逻辑</li>
<li>实例化其他模板</li>
</ul>
<p><code>.</code> 表示模板里的参数<br>
<code>range var</code> <code>end</code> 表示循环，此时的<code>.</code>表示var里的元素<br>
<code>|</code> 将上一个操作的结果作为下一个操作的输入，和管道类似。</p>
<p><strong>通过模板输出</strong>：</p>
<p><code>template.New</code> 创建并返回一个新的模板<br>
<code>Func</code> 添加函数到模板内部可以访问的函数列表<br>
<code>Parse</code> 解析文本模板<br>
<code>temlate.Must</code> 错误处理，详见5.9</p>
<pre><code class="language-go">temp1, err := template.New(&quot;name&quot;).Funcs(template.FuncMap{&quot;func1&quot;: func1}).Parse(text)
temp1 = temlate.Must(temp1)
</code></pre>
<p><code>html/template</code>包使用和<code>text/template</code>包里面一样的API和表达式语<br>
句，并且额外地对出现在HTML、JavaScript、CSS和URL中的字符串进行自动转义。</p>
<h2 id="第5章-函数">第5章 函数</h2>
<h3 id="51-函数声明">5.1 函数声明</h3>
<pre><code class="language-go">func name(parameter-list)(result-list){
    body
}
</code></pre>
<p>函数的基本内容略。</p>
<p>如果几个形参或返回值类型相同则可以简写：<code>a int, b int</code>-&gt;<code>a, b int</code></p>
<p>go函数支持复数返回值，并允许在返回值列表中显性声明变量，此时<code>return</code>的内容可省略，即裸返回。<br>
<code>func func1()(res int）{ ... ; return }</code></p>
<p>函数的类型称为 <strong>函数签名</strong> 。</p>
<p>有些函数声明没有函数体，说明这个函数使用了Go以外的语言实现。</p>
<h3 id="52-递归">5.2 递归</h3>
<p>略</p>
<h3 id="53-多返回值">5.3 多返回值</h3>
<p>如果一个函数返回一组值，想要使用这些返回值就必须显式地将其赋给变量。<br>
如果想要忽视其中一部分可以赋给空标识符<code>_</code>。<br>
一个多值调用可以当作多个参数进行传参。</p>
<h3 id="54-错误">5.4 错误</h3>
<blockquote>
<p>与许多其他语言不同，Go语言通过使用普通的值而非异常来报告错误。尽管Go语言有异常机制，这将在5.9节进行介绍，但是Go语言的异常只是针对程序bug导致的预料外的错误，而不能作为常规的错误处理方法出现在程序中。<br>
这样做的原因是异常会陷人带有错误消息的控制流去处理它，通常会导致预期外的结果:错误会以难以理解的栈跟踪信息报告给最终用户，这些信息大都是关于程序结构方面的而不是简单明了的错误消息。</p>
</blockquote>
<h4 id="541-错误处理策略">5.4.1 错误处理策略</h4>
<ol>
<li>传递错误，使子例程的错误变为主调例程错误。<br>
使用<code>fmt.Errorf()</code>格式化错误信息并返回新的错误值，为原始错误信息添加额外上下文信息来建立可读的错误描述。</li>
<li>对操作进行重试，超出次数或时间后再报错退出。</li>
<li>输出错误并停止程序。<br>
<code>fmt.Fprintf(os.Stderr, &quot;...%v...\n&quot;, err)</code><br>
<code>log.Fatalf(&quot;...%v\n&quot;, err)</code></li>
<li>只记下错误信息然后程序继续运行。</li>
</ol>
<h4 id="542-文件结束标识">5.4.2 文件结束标识</h4>
<p>io.EOF定义：</p>
<pre><code class="language-go">package io
import &quot;errors&quot;

// 当没有更多输入时返回EOF
var EOF =errors.New(&quot;EOF&quot;)
</code></pre>
<p>检测示例：</p>
<pre><code class="language-go">in := bufio.NewReader(os.Stdin)
for {
    r, _, err := in.ReadRune()
    if err == io.EOF {
        break //结束读取
    }
    if err != nil{
        return fmt.Errorf(&quot;read failed: %v&quot;, err)
    }
}
// ...使用r...
</code></pre>
<h3 id="55-函数变量">5.5 函数变量</h3>
<p>函数变量的零值为<code>nil</code>（空值），不能调用空的函数变量。</p>
<p>函数变量可以和空值比较的，但它们本身不可比较。</p>
<h3 id="56-匿名函数">5.6 匿名函数</h3>
<p>命名函数只能在包级别作用域声明。但使用 <strong>函数字面量</strong> 能在任何表达式内指定函数变量。函数字面量就像函数声明，但在func关键字后面没有函数的名称。它是一个表达式，它的值称作<strong>匿名函数</strong>。</p>
<p>更重要的是，以这种方式定义的函数能够获取到整个词法环境，因此里层的函数可以使用外层函数中的变量。</p>
<p><strong>警告：捕获迭代变量</strong>：</p>
<pre><code class="language-go">func main() {
    var printNums []func()
    nums := []int{1,2,3,4,5,6,7,8,9,10,11}
    for _, num := range nums {
        // num := num // 解决方法
        printNums = append(printNums, func() {
            fmt.Printf(&quot;%d &quot;, num) // NOTE: incorrect!
        })
    }
    for _, f := range printNums {
        f()
    }
    fmt.Println()
}
// $ go run main.go
// 11 11 11 11 11 11 11 11 11 11 11
</code></pre>
<p>在Go语言中，<strong>迭代变量捕获</strong>通常指的是在使用循环（如for循环）与匿名函数或闭包结合时，循环的迭代变量被闭包捕获的现象。这种情况下，如果闭包在其外部函数返回后仍然存活，并且在之后的某个时刻被调用，那么它访问的是迭代变量的最终值，而不是特定迭代中的值。</p>
<p>解决方法：<strong>用局部变量拷贝循环变量的值</strong>。</p>
<p>简单说就是闭包中存的迭代变量使用的是引用地址，而不是本身的值，所以迭代完成后存的是同一个地址。拷贝变量就为每次迭代分离出一个独立的地址。因为Go中为了方便，值和指针基本是混用的区别很少，所以可能不是很好理解。我也不确定我的理解对不对。</p>
<h3 id="57-变长函数">5.7 变长函数</h3>
<p>在参数列表最后的类型名称前使用省略号<code>...</code>声明变长函数，可以传递任意数目该类型的参数。<br>
当实参存在slice中时，在和后面放一个省略号来调用变长函数。以下两种调用等价：</p>
<pre><code class="language-go">func sum(vals ...int) int { }
values := []int{1,2,3,4}
sum(1,2,3,4)
sum(values...)
</code></pre>
<h3 id="58-延迟函数调用">5.8 延迟函数调用</h3>
<blockquote>
<p>语法上，一个defer语句就是一个普通的函数或方法调用，在调用之前加上关键字defer。函数和参数表达式会在语句执行时求值，实际的调用推迟到包含defer语句的函数结束后才执行。defer语句没有限制使用次数;执行的时候以调用defer语句顺序的<strong>倒序</strong>进行。</p>
</blockquote>
<h3 id="59-宕机">5.9 宕机</h3>
<blockquote>
<p>宕机发生时，程序执行终止，goroutine所有延迟函数执行，程序异常退出并留下日志信息，包括宕机的值（错误消息），函数调用的栈跟踪消息，用于诊断问题原因。</p>
</blockquote>
<h3 id="510-恢复">5.10 恢复</h3>
<p>8910这三部分其实都没看懂，勉强抄点书。</p>
<blockquote>
<p>如果内置的<code>recover</code>函数在延迟函数的内部调用，而且这个包含defer 语句的函数发生宕机，recover会终止当前的宕机状态并且返回宕机的值。函数不会从之前宕机的地方继续运行而是正常返回。如果recover在其他任何情况下运行则它没有任何效果且返回nil。</p>
</blockquote>
<pre><code class="language-go">func doSomethingThatPanic() { panic(&quot;something went wrong&quot;) }

func main() {
    defer func() {
        if r := recover(); r != nil {
            log.Printf(&quot;Recovered in main: %v&quot;, r)
        }
    }()

    doSomethingThatPanic()
    fmt.Println(&quot;This line will not be reached.&quot;)
}
</code></pre>
<h2 id="第6章-方法">第6章 方法</h2>
<h3 id="61-方法声明">6.1 方法声明</h3>
<p>方法声明和函数类似，但在前面多了一个参数，将方法显式地绑定在对应类型上。</p>
<p>Go语言中，接收者不使用如<code>this</code>或<code>self</code>的特殊名，而是自己定义。</p>
<p>Go和其他面向对象语言不同，可以把方法绑定到任何类型上，可以方便地为简单类型定义附加行为。</p>
<h3 id="62-指针接收者的方法">6.2 指针接收者的方法</h3>
<blockquote>
<p>由于主调函数会复制每一个实参变量，如果函数需要更新一个变量，或者如果一个实参太大而我们希望避免复制整个实参，因此我们必须使用指针来传递变量的地址。这也同样适用于更新接收者:我们将它绑定到指针类型，比如*Point。<br>
习惯上遵循如果Point的任何一个方法使用指针接收者，那么所有的Point方法都应该使用指针接收者，即使有些方法并不一定需要。</p>
</blockquote>
<p>关于实参接收者和形参接收者：</p>
<ul>
<li>同一类型，比如都是T或*T，没问题</li>
<li>实参T形参*T，编译器会隐式取地址</li>
<li>实参*T形参T，编译器会隐式解引用</li>
</ul>
<p>总之就是在调用方法时不用太在意类型，编译器基本都会隐式转换为合适的类型。这样做简洁明了，避开了指针这一个常规重难点，但有时也会引起混乱，分不清楚当前类型。</p>
<p><strong>nil是一个合法的接收者</strong>：</p>
<p>就像一些函数允许nil指针作为实参，方法的接收者也一样，尤其是当nil是类型中有意义的零值(如map和 slice 类型)时，更是如此，例如用<code>list *List = nil</code>表示空链表。当定义允许nil作为接收者时应该在注释中显式标明。</p>
<h3 id="63-通过接口提内嵌组成类型">6.3 通过接口提内嵌组成类型</h3>
<p>和前面匿名成员提到的内容差不多，不再赘述。</p>
<h3 id="64-方法变量与表达式">6.4 方法变量与表达式</h3>
<p>可以把方法赋给一个<strong>方法变量</strong>，它是一个函数，把方法绑定在一个接收者上，此时函数只需要提供实参不需要提供接收者。如<code>func1 := t.func; func1(a,b,c)</code></p>
<p>类似的还有<strong>方法表达式</strong>，必须提供接受者并按照选择子语法调用，把原来的接收者换成函数的第一个形参，可以像函数一样调用。如<code>func2 := T.func; func2(t,a,b,c)</code></p>
<h3 id="65-示例位向量">6.5 示例：位向量</h3>
<p>没啥内容</p>
<h3 id="66-封装">6.6 封装</h3>
<blockquote>
<p>Go语言只有一种方式控制命名的可见性:定义的时候，首字母大写的标识符是可以从包中导出的，而首字母没有大写的则不导出。同样的机制也同样作用于结构体内的字段和类型中的方法。结论就是，要封装一个对象，必须使用结构体。<br>
另一个结论就是在Go语言中封装的单元是包而不是类型。无论是在函数内的代码还是方法内的代码，结构体类型内的字段对于同一个包中的所有代码都是可见的。</p>
</blockquote>
<p>封装的优点：</p>
<ul>
<li>使用方不能直接修改对象的变量，不需要更多语句检查变量的值。</li>
<li>隐藏实现细节防止属性改变，设计者可以更灵活地改变API实现而不破坏兼容性。</li>
<li>防止使用者肆意更改对象内变量。</li>
</ul>
<h2 id="第7章-接口">第7章 接口</h2>
<h3 id="71-接口即约定">7.1 接口即约定</h3>
<p>接口是一种<strong>抽象类型</strong>，不暴露所含数据和内部结构，只提供一些方法。简单来说相当于提供一个黑盒，不用关心内部实现只要知道能干什么就行。其实我们学编程大部分适合也是学着使用一个个黑盒而已，只不过我们不止用还负责造罢了。</p>
<h3 id="72-接口类型">7.2 接口类型</h3>
<p>定义所含方法，嵌入其他接口，或者两者混用。这有必要单独开一节讲吗。。。</p>
<h3 id="73-实现接口">7.3 实现接口</h3>
<p>如果一个类型实现了接口要求的所有方法，那么这个类型实现了这个接口。这时我们常说某类型是一个（is a）特定的接口类型。</p>
<p>给接口赋值时，只有当表达式实现了接口时才能赋值给该接口。</p>
<p>接口封装了对应的类型和数据，只有通过接口暴露的方法才可以调用，类型的其他方法无法通过接口调用。</p>
<p><code>interface{}</code>被称为<strong>空接口类型</strong>。它对其实现类型没有任何要求，因此可以把任何值赋给空接口类型。</p>
<p>之后介绍了一下定义接口的方法，例如从类型出发，提取共性等等。</p>
<h3 id="74-使用-flagvalue-来解析参数">7.4 使用 flag.Value 来解析参数</h3>
<p>没啥内容，就一示例。</p>
<h3 id="75-接口值">7.5 接口值</h3>
<p>接口值分为两部分：一个具体类型和该类型的一个值，分别称为接口的动态类型和动态值。</p>
<p>讲什么编译时动态分发，没看懂。不过不影响用接口。</p>
<p>一个接口值可以指向多个任意大的动态值。 这段也没看懂。</p>
<ul>
<li>
<p><strong>接口值的比较</strong><br>
接口值可以用==和!=做比较。<br>
两个接口相等要求都是nil或动态类型和动态之都一致。<br>
因为接口值可以比较，所以可以作为map的键或则和switch的操作数。<br>
此外，接口值动态类型一致但动态值不可比较也很常见。<br>
相比其他类型的可比性是确定的，接口类型的比较必须是否小心确认其可比性。</p>
</li>
<li>
<p><strong>获取接口值动态类型</strong><br>
可以使用fmt包的%T实现。</p>
</li>
</ul>
<pre><code class="language-go">var w io.Writer
fmt.Printf(&quot;%T\n&quot;，w)//&quot;&lt;nil&gt;&quot;
w= os.Stdout
fmt.Printf(&quot;%T\n&quot;，w)//&quot;*os.File&quot;
w= new(bytes.Buffer)
fmt.Printf(&quot;%T\n&quot;,w)//&quot;*bytes.Buffer&quot;
</code></pre>
<p>在内部实现中，fmt用反射获取接口的动态类型，这将在12章详细讨论。</p>
<ul>
<li><strong>注意：含有空指针的非空接口</strong><br>
假设由如下代码</li>
</ul>
<pre><code class="language-go">var buf *bytes.Buffer
f(buf)

func f(out io.Writer){
    if(out!=nil){
        out.Write([]byte(&quot;done!\n&quot;))
    }
}
</code></pre>
<p>当函数运行到out.Write时会报错，因为out的值为空，即方法的接收者为空。前面我们说过，接口值包括动态类型值和动态值。在把形参的空指针buf赋给实参out时，out的动态类型由nil变为了*bytes.Buffer。而只有动态类型和动态值都为nil的接口值才为空，所以out通过了非空检查。</p>
<p>正确做法是一开始就把buf类型定义为io.Writer,避免把功能不完整的值（仅有类型）赋给接口。</p>
<h3 id="76-使用-sortinterface-来排序">7.6 使用 sort.Interface 来排序</h3>
<p>一个接口的使用示例</p>
<h3 id="77-httphandler-接口">7.7 http.Handler 接口</h3>
<p>接口的使用示例，介绍一个特殊的接口http.Handler，但我没看懂特殊在哪，而且对http相关也不熟悉，到底什么课会教啊，怎么感觉不管看什么都默认对它很熟悉的样子。。。</p>
<h3 id="78-error-接口">7.8 error 接口</h3>
<p>这里还找到个错，书上“包含”写成“不含”了。投稿会不会给我钱（想peech）</p>
<p>后面好像全是示例，先跳一下吧。</p>
<h3 id="79-示例表达式求值器">7.9 示例：表达式求值器</h3>
<h3 id="710-类型断言">7.10 类型断言</h3>
<p><a href="https://zhuanlan.zhihu.com/p/675924965">一文掌握 Golang 中的类型断言</a><br>
书上原文讲的有点散，换了篇更通俗的文自己看。有时候学东西没必要死磕，看看别人怎么讲的对照一下说不定更好理解。</p>
<p>Golang 中的接口是一种抽象类型，可以存储任何实现了该接口方法的类型实例。然而，由于接口本身不包含类型信息，需要通过类型断言来将接口变量转换为实际类型。基本语法如下：<br>
<code>value, ok := x.(T)</code><br>
x 是一个接口类型的变量，T 是希望断言的类型。value 将会是 x 转换为类型 T 后的值，ok 是一个布尔值，当类型断言成功时为 true，失败时为 false 。也可以不带ok，但如果断言失败会引发 panic。</p>
<p>x 必须是接口类型，非接口类型的 x 不能做类型断言。<br>
T如果是非接口类型，检查x的动态类型是否为T，即 T 应该实现 x 的接口。<br>
T 如果是接口，则 x 的动态类型也应该实现接口 T。<br>
如果操作数是空接口值，则类型断言失败。</p>
<h3 id="711-使用类型断言来识别错误">7.11 使用类型断言来识别错误</h3>
<p>MARK<br>
没怎么看懂，好像大概意思就是通过断言转换成特定类型，含有更多的信息。<br>
再给给个例子说明，并提示通过fmt.Errorf等合并错误消息可能丢失结构信息，最好在失败操作发生时马上处理错误，而不是返回给调用者后。</p>
<h3 id="712-通过接口类型断言来查询特性">7.12 通过接口类型断言来查询特性</h3>
<p>咕，看不懂。接口这个东西放到实战怎么能衍生出这么多复杂东西。我还以为有个方法就算接口了，结果用起来千奇百怪，也不知道是go的特性还是其他面向对象语言都这样。</p>
<h3 id="713-类型分支">7.13 类型分支</h3>
<p>MARK<br>
关于联合，可识别联合，类型多态，特设多态等一大堆专有名词没看懂。</p>
<p>简单来说，<code>x.(type)</code>可以返回类型，配合switch和重用变量名可以很方便判断类型并操作：</p>
<pre><code class="language-go">func sqlQuote(x interface{}) string {
 switch x := x.(type) {
 case nil:
  return &quot;NULL&quot;
 case int, uint:
  return fmt.Sprintf(&quot;%d&quot;, x) //这里x类型为interface{}
 case bool:
  if x {
   return &quot;TRUE&quot;
  }
  return &quot;FALSE&quot;
 case string:
  return sqlQuotestring(x) //(未显示具体代码)
 default:
  panic(fmt.Sprintf(&quot;unexpected type %T:%v&quot;, x))
 }
}
</code></pre>
<h3 id="714-示例基于标记的xml解析">7.14 示例：基于标记的XML解析</h3>
<p>看得脑子一团浆糊，先看看别的换换脑子吧。是我前置知识不够吗？在学校的时候应该多学点的。</p>
<h3 id="715-一些建议">7.15 一些建议</h3>
<p>MARK<br>
略</p>
<h2 id="第8章-goroutine和通道">第8章 goroutine和通道</h2>
<h3 id="81-goroutine">8.1 goroutine</h3>
<p>go的并发相对其他编程语言很简单，只需要在函数或方法前加上<code>go</code>关键字即可创建一个goroutine并发执行操作。goroutine类似于线程，但其实是一个更小的单位。</p>
<h3 id="82-示例并发时钟服务器">8.2 示例：并发时钟服务器</h3>
<p>略，很简单的一个例子，顺便介绍了时间格式化。</p>
<h3 id="83-示例并发回声服务器">8.3 示例：并发回声服务器</h3>
<p>略，很简单的一个例子</p>
<h3 id="84-通道">8.4 通道</h3>
<p>通道是可以让一个goroutine发送特定值到另一个goroutine的通信机制。通道的类型为<code>chan</code>。</p>
<pre><code class="language-go">ch := make(chan int)
</code></pre>
<p>通道是一个使用make创建的数据结构的引用。当复制或参数传递时引用同一份数据结构，零值为nil。<br>
同种类型的通道可以比较，当引用同一通道数据时返回true，也可以和nil进行比较。</p>
<p>通道的两个操作：发送和接收，都使用操作符<code>&lt;-</code>，数据从右到左传递。在接收表达式中，结果未使用也是合法的。</p>
<pre><code class="language-go">ch &lt;- x     // 发送语句
x = &lt;- ch   // 赋值语句，接收表法式
&lt;- ch       // 接收语句，丢弃结果
</code></pre>
<p>可以使用<code>close(ch)</code>来关闭通道。它设置一个标志位来指示通道关闭。关闭后发送将宕机（panic），关闭后接收将获取发送的值直到通道为空。此时接收操作完成并获取通道元素类型对应的零值。</p>
<p>make不带参数创建的为 <strong>无缓冲通道</strong>，也可以带一个可选参数表示通道容量来创建 <strong>缓冲通道</strong>。</p>
<h4 id="841-无缓冲通道">8.4.1 无缓冲通道</h4>
<p>无缓冲通道上的发送和执行操作将 <strong>堵塞</strong> ，直到另一方执行相反操作。这将导致发送和接收goroutine <strong>同步化</strong> ，因此无缓冲通道也被称为 <strong>同步通道</strong> 。</p>
<p>当x即不比y早也不比y晚时称x和y并发，但顺序是不确定的，需要主动排序。</p>
<p>一点点错误处理知识，略。</p>
<p>强调通道本身及通讯发送时间等方面时，把消息叫做<strong>事件</strong>。当事件没有携带消息，只用于进行同步时，通过一个struct{}类型的通道来强调它<code>done &lt;- struct{}{}</code></p>
<h4 id="842-管道">8.4.2 管道</h4>
<p>通道可以连接goroutine，使一个的输出成为另一个的输入，即管道（pipeline）。</p>
<p>没有一个直接的方式判断通道是否以及关闭，但可以通过接收结果间接判断。</p>
<pre><code class="language-go">go func(){
    for {
        x,ok := &lt;- ch
        if !ok {
            break // 通道关闭且读完
        }
        // ...
    }
}
</code></pre>
<p>关闭每一个通道不是必须的，只有通知接收方goroutine所有数据发送完毕才需要关闭通道。垃圾回收器将根据是否可访问来回收，而不是是否关闭。<br>
关闭已关闭的通道和关闭空通道都会导致宕机。关闭通道也可以作为一个广播机制，详见8.9。</p>
<h4 id="843-单向通道类型">8.4.3 单向通道类型</h4>
<p>为了文档化限制通道仅发送或仅接收的意图，Go提供了<em>单向</em>通道类型，<code>chan&lt;-</code><em>只能发送</em>，<code>&lt;-chan</code><em>只能接收</em>，违反这个原则会在编译时被检查出来。</p>
<p>close操作说明的是通道上没有数据再发送，所以只能关闭发送通道，关闭仅接收通道会在编译时报错。</p>
<p>赋值操作或者参数调用可以把双向通道转化为单向通道，但反过来不行。</p>
<h4 id="844-缓冲通道">8.4.4 缓冲通道</h4>
<p>可以通过<code>cap(ch)</code>获取缓冲区容量，<code>len(ch)</code>获取通道内元素个数。</p>
<p>MARK<br>
一点关于goroutine泄露的内容，不是很懂。</p>
<p>最后介绍一点缓冲和无缓冲的区别，用流水线作例子。有点似懂非懂。</p>
<h3 id="85-并行循环">8.5 并行循环</h3>
<p>MARK<br>
看是看懂了好像，但找不出重点。以后需要些并行循环时再回来看看吧。</p>
<h3 id="86-示例并发的web爬虫">8.6 示例：并发的Web爬虫</h3>
<p>MARK<br>
提了一下避免死锁，但没有展开，我也不知道为什么会导致死锁<br>
之后介绍并行度不是越高越好，总有各种限制。<br>
使用容量为n的缓冲通道建立并发原语，称为 <em>计数信号量</em>。每一个孔宪草表示一个令牌，保证没有接收操作时最多由n个发送。<br>
另一种方法是通过n个长期存活的goroutine调用，保证最多只有n个并发。</p>
<h3 id="87-使用select多路复用">8.7 使用select多路复用</h3>
<p><strong>select多路复用示例</strong>：</p>
<pre><code class="language-go">select {
    case &lt;-ch1:
        // ...
    case x := &lt;-ch2:
        // ...use x...
    case ch3 &lt;- y:
        // ...
    default:
        // ...
}
</code></pre>
<p>select将保持等待直到出现通信，然后进行这次通信并执行对应语句。<br>
如果没有对应情况将永远等待。可以设置一个<code>&lt;-time.After(...)</code>来实现超时退出。<br>
如果多个情况同时满足，select将随机选择一个。</p>
<p>此外还介绍了计时器<code>time.tick</code>怎么避免goroutine泄露。</p>
<p>可以使用select实现<em>非阻塞</em>通信。select的<code>default</code>用于指定没有其他通信发生时立即执行的动作，这是一个非阻塞的动作，重复这个动作称为对通道<em>轮询</em>。</p>
<h3 id="88-示例并发目录遍历">8.8 示例：并发目录遍历</h3>
<p>进一步介绍并发的写法，引入select，time.Tick，break loop，sync.WaitGroup,计数信号量等。</p>
<h3 id="89-取消">8.9 取消</h3>
<p>可以创建一个取消通道，再上面不发送任何值，关闭表示取消该goroutine。同时定义一个工具函数cancelld，被调用时检测或轮询取消状态。</p>
<pre><code class="language-go">var done = make(chan struct{})

func cancelled() bool {
    select {
        case &lt;-done:
            return true
        default:
            return false
    }
}
</code></pre>
<p>创建一个goroutine，堵塞地等待触发条件，如果满足条件就通过关闭goroutine来关闭done通道来广播取消事件。</p>
<pre><code class="language-go">// 当检测到输入时取消遍历
go func() {
    os.Stdin.Read(make([]byte,1)) // 读一个字节
    close(done)
}
</code></pre>
<p>在主goroutine添加关闭通道后的处理：</p>
<pre><code class="language-go">for{
    select{
        case &lt;-done:
            // 处理一些待完成任务，相当于退出函数
            return
    }
}
</code></pre>
<p>让子goroutine在开始时轮询取消状态，如果已被取消，则什么都不做立即返回。</p>
<pre><code class="language-go">go func ... {
    if cancelled(){
        return
    }
    // 正常子goroutine内容
}
</code></pre>
<p>MARK：<br>
最后介绍一点程序退出后的清理，这部分没看懂。</p>
<h3 id="810-示例聊天服务器">8.10 示例：聊天服务器</h3>
<p>MARK：<br>
暂略</p>
<h2 id="第9章-使用共享变量实现并发">第9章 使用共享变量实现并发</h2>
<h3 id="91-竞态">9.1 竞态</h3>
<p>考虑一个在串行程序中正确工作的函数，如果它在并发调用时仍能正确工作，那么这个函数是<em>并发安全</em>的。<br>
程序并发安全不需要每一个类型都是并发安全的。对于绝大部分变量，如果要回避并发访问，要么<em>限制</em>变量只存在一个goroutine内，要么维护一个更高层的<em>互斥不变量</em>。<br>
导出的包级别函数通常可以认为是并发安全的，因为包级别变量无法限制在一个gouroutine内，修改这些变量的函数必须采用互斥机制。</p>
<p><strong>数据竞态</strong>：两个goroutine并发读写同一个变量且至少一个是写入。</p>
<ol>
<li>不要修改变量。<br>
e.g. 直接初始化全局变量且不再修改。</li>
<li>避免从多个goroutine访问同一个变量。<br>
必须使用通道来发送查询请求或更新变量。<br>
“不要通过共享内存来通信，而应该通过通信来共享内存”<br>
即使变量不能受限于单个goroutine，也可以借助通道传递变量地址实现变量共享，即<strong>串行受限</strong>。</li>
<li>同一时间只有一个goroutine可以访问变量，即<strong>互斥机制</strong>。见下节。</li>
</ol>
<h3 id="92-互斥锁-syncmutex">9.2 互斥锁 sync.Mutex</h3>
<p>可以使用容量为1的通道保证同时只有一个goroutine访问共享变量，即<strong>二进制信号量</strong>。</p>
<pre><code class="language-go">var(
    sema = make(chan struct{}, 1)
    v int
)

func Use(){
    sema &lt;- struct{}{} // 获取令牌
    defer &lt;- sema // 释放令牌
    // 使用变量v
}
</code></pre>
<p><code>sync</code>包有一个单独的<code>Mutex</code>变量支持互斥锁模式。</p>
<pre><code class="language-go">var(
    mu = sync.Mutex
    v int
)

func Use(){
    mu.Lock() // 获取令牌
    defer mu.Unlock() // 释放令牌
    // 使用变量v
}
</code></pre>
<p>Go语言的互斥量是不可<strong>再入</strong>的（不能对已上锁互斥量再次上锁），所以嵌套申请互斥锁将导致死锁。<br>
MARK<br>
这里关于go互斥量不可再入的理由和解决方法没完全懂。</p>
<h3 id="93-读写互斥锁syncrwmutex">9.3 读写互斥锁：sync.RWMutex</h3>
<p>多个读操作可以安全并发运行，但写操作需要独享的访问权限，这种锁称为<strong>多读单写锁</strong>，可以通过go的<code>sync.RWMutex</code>实现。</p>
<pre><code class="language-go">var mu sync.RWMutex
var v int

func Read() int {
    mu.RLock() // 读锁
    defer mu.RUnlock()
    return v
}
</code></pre>
<p><code>RLock</code>只能用于无写操作，但逻辑上只读的操作不一定没有写操作，如递增计数器或更新缓存。如果不确定是否有写操作仍以使用<code>Lock</code>。<br>
因为需要更复杂的内部工作，只在竞争激烈时<code>RWMutex</code>才有优势，否则它比普通的互斥锁慢。</p>
<h3 id="94-内存同步">9.4 内存同步</h3>
<p>MARK<br>
介绍了一种由内存的本地缓存可能引发的问题，结论是尽量限制变量在单个goroutine内或使用互斥锁来避免数据竞态。</p>
<h3 id="95-延迟初始化synconce">9.5 延迟初始化：sync.Once</h3>
<p>对于那些一次性初始化以及初始化非必须的变量，如果直接用判<code>v!=nil</code>是并发不安全的，因为初始化时首先将v使用make构造再进行赋值操作，在这期间判得v!=nil但读不到正确值。<br>
如果直接使用Mutex无法并发读，使用RWMutex实现并发安全较为复杂。<br>
可以使用<code>sync.Once</code>实现这一并发安全，它包含一个布尔变量和一个互斥量，前者记录初始化是否完成，后者保护数据。</p>
<pre><code class="language-go">var once sync.Once
var v map[string]int

func InitV(){...}

func GetV(s string)(int){
    once.Do(InitV)
    return v[s]
}
</code></pre>
<h3 id="96-竞态检测器">9.6 竞态检测器</h3>
<p>go工具链有一个动态分析工具：<strong>竞态检测器</strong>（race detector），将<code>-race</code>参数加到<code>go build</code>,<code>go run</code>,<code>go test</code>命令中即可使用。<br>
竞态检测器只能检测到运行时发生的竞态，所以需要晚完善的测试用例以获得最佳效果。</p>
<h3 id="97-示例并发非阻塞缓存">9.7 示例：并发非阻塞缓存</h3>
<p>TODO：<br>
看困了，以后再看。<br>
有个<code>singleflight</code>包好像也能实现这个需求。</p>
<h3 id="98-goroutine-与线程">9.8 goroutine 与线程</h3>
<h4 id="981-可增长的栈">9.8.1 可增长的栈</h4>
<p>OS线程的栈内存是固定大小（通常为2MB）。<br>
goroutine的栈内存是可增长的，初始通常为2KB，最大可达1GB。</p>
<h4 id="982-goroutine-调度">9.8.2 goroutine 调度</h4>
<p>线程由内核调度，通过硬件时钟触发，线程切换需要一个完整的上下文切换，成本高操作慢。<br>
goroutine由Go自己的调度器调度，使用<code>m:n</code>调度（复用/调度m个goroutine到n个OS线程），通过特定的go语言结构触发，不需要切换到内核语境，成本低很多。</p>
<h4 id="983-gomaxprocs">9.8.3 GOMAXPROCS</h4>
<p>Go调度器使用<code>GOMAXPROCS</code>参数确定使用多少个OS线程同时执行Go代码，默认值是机器CPU数量（m:n 调度中的n）。休眠或通道通信阻塞的goroutine不占用线程。I/O阻塞和其他系统调用或非Go函数的goroutine需要独立OS线程，但不计算在<code>GOMAXPROCS内</code>。</p>
<p>可以用<code>GOMAXPROCS</code>环境变量或<code>runtime.GOMAXPROCS</code>函数显式控制该参数。</p>
<h4 id="984-goroutine-没有标识">9.8.4 goroutine 没有标识</h4>
<p>在大部分支持多线程的操作系统和编程语言中，线程都有一个独特的标识（通常是一个整数或指针），本质上是一个全局map，能够轻松构建一个线程的局部储存。</p>
<p>goroutine在设计中没有提供这个标识，这是为了避免线程局部存储被滥用，鼓励一种更简单的编程风格。</p>
<h2 id="第10章-包和-go-工具">第10章 包和 go 工具</h2>
<h3 id="101-引言">10.1 引言</h3>
<h3 id="102-导入路径">10.2 导入路径</h3>
<h3 id="103-包的声明">10.3 包的声明</h3>
<p>每个go源文件开头都需要进行包声明，作为被其他包引入时的标识符。</p>
<h3 id="104-导入声明">10.4 导入声明</h3>
<p>导入多个包时可以使用多个import声明导入，也可以使用一个<code>import (...)</code>一次性导入多个包。一般后者更常见。</p>
<pre><code class="language-go">import (
    &quot;fmt&quot;
    &quot;os&quot;
)
</code></pre>
<p>导入两个同名包时，需要指定别名避免冲突，也就是 <strong>重命名导入</strong>。<br>
即使没有包名冲突，也可以使用重命名导入来简化包名或者避免局部变量冲突。</p>
<pre><code class="language-go">import (
    &quot;crypto/rand&quot;
    mrand &quot;math/rand&quot;
)
</code></pre>
<h3 id="105-空导入">10.5 空导入</h3>
<p>可以通过将别名设置为<code>_</code>的方式实现<strong>空白导入</strong>，例如<code>import _ &quot;image/png&quot; // 注册png解码器</code>。多数情况下，它用来实现一个编译时的机制，开启主程序中可选的特性。</p>
<p>比起图片格式解码器，数据库驱动程序中用到的空白导入对我而言更为熟悉。</p>
<pre><code class="language-go">package main

import (
	&quot;database/sql&quot;

	_ &quot;github.com/go-sql-driver/mysql&quot; // 添加 MySQL 支持
	_ &quot;github.com/lib/pq&quot;              // 添加 Postgres 支持
)

db, err = sql.Open(&quot;postgres&quot;, dbname) // 0K
db, err = sql.Open(&quot;mysql&quot;, dbname)    // 0K
db, err = sql.Open(&quot;sqlite3&quot;, dbname)  //返回错误消息:unknown driver“sqlite3&quot;
=
</code></pre>
<h3 id="106-包及其命名">10.6 包及其命名</h3>
<h3 id="107-go-工具">10.7 go 工具</h3>
<h4 id="1071-工作空间的组织">10.7.1 工作空间的组织</h4>
<p>现在都用go module不用gopath了，略。</p>
<h4 id="1072-包的下载">10.7.2 包的下载</h4>
<h4 id="1073-包的构建">10.7.3 包的构建</h4>
<h4 id="1074-包的文档化">10.7.4 包的文档化</h4>
<p><code>go doc</code>命令可以输出包的注释和内部声明，也可以输出包成员或方法的注释。</p>
<p><code>godoc</code>在新版本不再内置，通过<code> go install golang.org/x/tools/cmd/godoc@latest</code>安装。</p>
<p>运行命令<code>godoc -http=:6060 -play -index</code>，之后访问<code>localhost:6060</code>，就可以以互相链接的网页的形式查看注释文档了。官方的<code>pkg.go.dev</code>也是用的这种方式。</p>
<h4 id="1075-内部包">10.7.5 内部包</h4>
<p><code>go build</code>工具会特殊对待<code>internal</code>路径下的包，即 <strong>内部包</strong>。内部包只能被<em>internal父目录为根的目录树</em>下的包导入。</p>
<h4 id="1076-包的查询">10.7.6 包的查询</h4>
<p><code>go list</code> 工具将给出可用包的信息。参数也可以包含<code>...</code>通配符，将匹配任意字串。<code>go list</code>用法如下：</p>
<ul>
<li><code>go list &lt;包名&gt;</code> 判断包是否存在于工作空间，如果存在将输出导入路径。</li>
<li><code>go list ...</code> 枚举工作空间中的所有包</li>
<li><code>go list &lt;路径&gt;/...</code>一个指定子树中的所有包</li>
<li><code>go list ...&lt;关键字&gt;...</code> 查询路径包含关键字的包</li>
</ul>
<p><code>go list</code>命令获取的是完整元数据，而不仅仅是导入路径。可以使用<code>-json</code>,<code>-f</code>等标记定制输出内容和格式。</p>
<h2 id="第11章-测试">第11章 测试</h2>
<h3 id="111-go-test-工具">11.1 go test 工具</h3>
<p><code>_test.go</code>结尾的文件不是<code>go build</code>编译的目标，而是<code>go test</code>编译的目标。</p>
<p><code>*_test.go</code>中有三种特殊函数：</p>
<ul>
<li><strong>功能测试函数</strong>：<br>
Test前缀，检测逻辑正确性，结果为PASS或FAIL</li>
<li><strong>基准测试函数</strong>：<br>
Benchmark开头，测试操作性能，结果为平均执行时间</li>
<li><strong>示例函数</strong>：<br>
Example开头，提供机器检查过的文档</li>
</ul>
<h3 id="112-test-函数">11.2 Test 函数</h3>
<p>功能测试函数必须以Test开头，后缀名以大写字母开头，如下是一个测试函数示例：</p>
<pre><code class="language-go">type TestCase struct{
    input interface{}
    want interface{}
}

func TestFunc(t *testing.T) {
    var tests = []TestCase
    // 初始化测试用例
    for test := range tests{
        if got := Func(test.input); got != test.want{
            t.Errorf(&quot;Func(%v) = %v , want %v&quot;,test.input, got, test.want)
        }
    }
}
</code></pre>
<p><code>go test</code>在不指定包参数时以当前目录所在包为参数。可选的命令行参数如下：</p>
<ul>
<li><code>-v</code><br>
输出包中每个测试用例的名称和执行时间</li>
<li><code>-run</code> = 正则表达式<br>
只运行测试函数名称匹配给定模式的函数</li>
</ul>
<h4 id="1121-随机测试">11.2.1 随机测试</h4>
<p>要确定随机输入的正确输出有两种方法：</p>
<ul>
<li>使用低效但清晰的算法，比较结果是否一致。</li>
<li>构建符合模式的输入，从而知道对应输出。</li>
</ul>
<p>使用<code>rand.New(rand.NewSource(time.Now().UnixNano()))</code>生成随机数种子，进而生成随机输入。在保存测试用例的输入时，比起保存整个输入数据结构，记录随机数种子更简便。</p>
<h4 id="1122-测试命令">11.2.2 测试命令</h4>
<p>go test除了测试代码也可用于测试命令。</p>
<h4 id="1123-白盒测试">11.2.3 白盒测试</h4>
<p><strong>黑盒测试</strong>：假设测试者仅了解公开API和文档，而内部逻辑不透明。<br>
<strong>百合测试</strong>： 可以访问包的内部函数和数据结构，并且可以做一些常规用户无法做到的观察和改动。</p>
<p>在进行白盒测试时，可以保存全局变量或方法后更新其值，最后使用defer恢复，从而实现更精细的调试。</p>
<pre><code class="language-go">// develop file
var globalVar := 10

func globalFunc( ) { 
    //... 
}

targetFunc( ) {
    // used globalVar
    // used globalFunc
}

// test file
func testFunc(t testing.T){
    // 保存原变量和方法
    savedVar = globalVar
    savedFunc = globalFunc
    // 退出时恢复原值
    defer func ( ) {
        globalVar = savedVar
        globalFunc = savedFunc
    }

    // 定义用于测试的变量和方法
    globalVar = newVar
    globalFunc = newFunc

    // 测试targetFunc，将使用赋的新值
}
</code></pre>
<h4 id="1124-外部测试包">11.2.4 外部测试包</h4>
<h4 id="1125-编写有效测试">11.2.5 编写有效测试</h4>
<h4 id="1126-避免脆弱的测试">11.2.6 避免脆弱的测试</h4>
<p>TODO：<br>
不是很懂</p>
<h3 id="113-覆盖率">11.3 覆盖率</h3>
<h3 id="114-benchmark-函数">11.4 Benchmark 函数</h3>
<h3 id="115-性能刨析">11.5 性能刨析</h3>
<h3 id="116-example-函数">11.6 Example 函数</h3>
<p>OMIT：<br>
略 需要再查</p>
<h2 id="第12章-反射">第12章 反射</h2>
<h3 id="121-为什么使用反射">12.1 为什么使用反射</h3>
<p>有时需要写一个统一处理各种类型的函数（如Printf），但这些类型可能：</p>
<ul>
<li>无法共享同一个接口</li>
<li>布局位置</li>
<li>在设计函数时不存在</li>
</ul>
<h3 id="122-reflecttype-和-reflectvalue">12.2 reflect.Type 和 reflect.Value</h3>
<p><code>reflect.TypeOf</code>接受<code>interface{}</code>参数，并将接口中动态类型以<code>reflect.Type</code>形式返回。</p>
<pre><code class="language-go">t := reflect.TypeOf(3)      // reflect.Type
fmt.Println(t)                  // int
fmt.Println(t.String())     // int
</code></pre>
<p><strong>注意</strong>：<code>reflect.TypeOf</code>总是返回具体类型，而不是接口类型。所以可以使用<code>%T</code>直接获取接口的具体类型：</p>
<pre><code class="language-go">fmt.Printf(&quot;%T\n&quot;, 3)  // &lt;int Value&gt;
</code></pre>
<p><code>reflect.ValueOf</code>接受<code>interface{}</code>参数，并将接口中动态值以<code>reflect.Value</code>形式返回。<br>
这里说返回值是具体值，但 <strong>也可以包含一个接口值</strong>。在接口部分我们了解到接口值包括动态类型和动态值，即<code>reflect.Value</code>也是包含动态值和动态类型的，调用Value的Type方法将类型以 <code>reflect.Type</code>返回。<br>
<code>reflect.ValueOf</code>的逆操作是``reflect.Value.Interface<code>方法，返回一个</code>interface{}<code>接口值，与</code>reflect.Value`值相同。</p>
<pre><code class="language-go">var i interface{} = 3
fmt.Println(i)        // 3
fmt.Printf(&quot;%v\n&quot;, i) // 3
fmt.Printf(&quot;%T\n&quot;, i) // int

v := reflect.ValueOf(i)
fmt.Println(v)          // 3
fmt.Println(v.Int())    // 3
fmt.Println(v.Type())   // int
fmt.Println(v.String()) // &lt;int Value&gt;

x := v.Interface()
fmt.Println(x)              // 3
fmt.Printf(&quot;%d\n&quot;, x.(int)) // 3
fmt.Printf(&quot;%T\n&quot;, x.(int)) // int
</code></pre>
<p><code>reflect.Value</code>和<code>interface{}</code>都可以包含任意值，区别是空接口隐藏了值的信息，需要先进行类型断言否则操作有限，而<code>reflect.Value</code>有很多方法去分析值而不用知道类型。</p>
<p>可以使用<code>reflect.Value</code>的<code>kind</code>方法来区分类型:</p>
<ul>
<li>基础类型：Bool，String，以及各种数字类型</li>
<li>聚合类型：Array和Struct</li>
<li>引用类型：Chan，Func，Prt，Slice和Map</li>
<li>接口类型：Interface</li>
<li>Invalid类型：表示没有任何值，如<code>reflect.Value</code>的零值</li>
</ul>
<h3 id="123-display-一个递归的值显示器">12.3 Display: 一个递归的值显示器</h3>
<h3 id="124-示例-编码s表达式">12.4 示例: 编码S表达式</h3>
<p>OMIT: 示例略</p>
<h3 id="125-使用-reflectvalue-来设置值">12.5 使用 reflect.Value 来设置值</h3>
<p>一个变量是一个<strong>可寻址</strong>的存储区域，其中包含一个值，并且可以通过这个地址来更新。对<code>reflect.Value</code>也有类似区分，只有可寻址的Value才能用于更新变量。</p>
<p>调用<code>reflect.ValueOf(&amp;x).Elem()</code>来获得任意变量x的可寻址的Value值。对slice的e[i]也有<code>reflect.ValueOf(e).Index(i)</code>，得到的Value也是可寻址的，有一定的指针基础会更好理解。<br>
通过<code>reflect.Value.CanAddr()</code>可以询问Value变量是否可寻址。</p>
<p>从一个可寻址的<code>reflect.Value()</code>获取变量有如下三步：</p>
<ol>
<li>调用Addr()，返回一个Value，包含指向变量的指针。</li>
<li>调用Interface()，返回包含该指针的interface{}值。</li>
<li>使用类型断言将接口转换成普通指针。</li>
</ol>
<p>然后就可以使用这个指针来更新变量了。<br>
也可以使用<code>reflect.Value.Set()</code>直接从可寻址的Value来更新变量。</p>
<pre><code class="language-go">x := 2
d := reflect.ValueOf(&amp;x).Elem()   // d refers to the variable x
px := d.Addr().Interface().(*int) // px := &amp;x
*px = 3                           // x=3
fmt.Println(x)                    // 3

d.Set(reflect.ValueOf(4))
fmt.Println(x)                    // 4
</code></pre>
<h3 id="126-示例解码s表达式">12.6 示例：解码S表达式</h3>
<p>OMIT: 示例略。</p>
<h3 id="127-访问结构体字段标签">12.7 访问结构体字段标签</h3>
<p>主要介绍通过反射去解析字段标签的底层实现，例如解析http请求并将参数绑定到结构体上。<br>
大致过程是通过Field和Tag等方法解析结构体中的字段和标签，通过kind方法分类http请求中的数据类型选择合适的方法赋值。现在用的web框架都把这些底层逻辑封装好了，有需要时再翻书。</p>
<h3 id="128-显示类型的方法">12.8 显示类型的方法</h3>
<p><code>reflect.Type</code>和<code>reflect.Value</code>都有<code>Method(i)</code>方法，前者返回<code>reflect.method</code>类型的实例，描述方法的名称和类型等。后者返回一个<code>reflect.Value</code>类型的方法值，可以通过<code>reflect.Value.Call</code>进行调用。</p>
<h3 id="129-注意事项">12.9 注意事项</h3>
<ul>
<li>基于反射的代码很脆弱。编译时能报错的错误，使用反射只有在执行时才会崩溃报告。
<ul>
<li>将反射的使用完整地封装在包内。</li>
<li>包的API中避免使用reflect.Value，而是特定类型。</li>
<li>每个危险操作前做额外的动态检查。</li>
</ul>
</li>
<li>反射降低了自动重构和分析工具的安全性与准确度，因为它们无法检测到类型信息。类型也算文档的一直，而反射相关操作无法做静态类型检查。</li>
<li>基于反射的函数比特定类型优化的函数慢一两个数量级。</li>
</ul>
<h2 id="第13章-低级编程">第13章 低级编程</h2>
<p>很多实现细节无法通过Go程序访问，通过隐藏底层细节，Go程序有着更好的可读性和可移植性。但有时也可以放弃一些有益的保证去追求高性能，和其他语言交互和实现纯Go无法描述的函数。</p>
<p>这一章主要是读一下扩宽视野，掌握一些与操作系统底层交互的方式，普通程序用不上低级编程。<br>
有C/C++基础看这些内容就跟回家了一样。</p>
<h3 id="131-unsafesizeof-alignof-和-offsetof">13.1 unsafe.Sizeof、Alignof 和 Offsetof</h3>
<p>关于内存对齐的知识和方式。个人感觉平时编程其实不用关注内存对齐，关注那点内存提升不如提升可读性。真搞高性能要求的开发之类还是用C。</p>
<h3 id="132-unsafepointer">13.2 unsafe.Pointer</h3>
<p>指针相关内容，C++的指针本质上只是一个内存地址，可以往里面写入任何数据。Go原本的指针做了个类型封装，而unsafe.Pointer相当于解除了这个限制。使用unsafe.Pointer还有很多注意事项，有需要再回来翻一下。</p>
<h3 id="133-示例深度相等">13.3 示例：深度相等</h3>
<p><code>reflect.DeepEqual</code>判断两个变量的值是否&quot;深度&quot;相等。对基本数据类型使用==进行比较，对组合类型逐层深入比较。<br>
<strong>注意</strong>：对nil和空结构体将判断为不相等。如 <code>reflect.DeepEqual(nil,[]string{})</code>结果为false。</p>
<p>OMIT: 示例略。</p>
<h3 id="134-使用cgo调用c代码">13.4 使用cgo调用C代码</h3>
<p>简单介绍cgo的用法，有需要再回来翻书。</p>
<h3 id="135-关于安全的注意事项">13.5 关于安全的注意事项</h3>
<p>高级语言隔离了许多底层细节，让我们可以编写安全健壮的代码并在任何操作系统上运行。<br>
包unsafe可以穿透这层隔离去使用一些特性或实现更高性能，代价则是可移植性和安全性，需要自己评估风险。大多数时候我们都不需要用到unsafe包，如果确实需要使用，则尽可能限制在小范围内。</p>
<hr>
<p>完结撒花🎉</p>
<p>2025.1.18</p>

          <div class="toc-container"><ul class="markdownIt-TOC">
<li><a href="#go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0">《Go程序设计语言》阅读笔记</a>
<ul>
<li><a href="#%E7%AC%AC1%E7%AB%A0-%E5%85%A5%E9%97%A8">第1章 入门</a></li>
<li><a href="#%E7%AC%AC2%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84">第2章 程序结构</a>
<ul>
<li><a href="#21-%E5%90%8D%E7%A7%B0">2.1 名称</a></li>
<li><a href="#22-%E5%A3%B0%E6%98%8E">2.2 声明</a></li>
<li><a href="#23-%E5%8F%98%E9%87%8F">2.3 变量</a>
<ul>
<li><a href="#231-%E7%9F%AD%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E">2.3.1 短变量声明</a></li>
<li><a href="#232-%E6%8C%87%E9%92%88">2.3.2 指针</a></li>
<li><a href="#233-new-%E5%87%BD%E6%95%B0">2.3.3 new 函数</a></li>
<li><a href="#234-%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">2.3.4 变量的生命周期</a></li>
</ul>
</li>
<li><a href="#24-%E8%B5%8B%E5%80%BC">2.4 赋值</a>
<ul>
<li><a href="#241-%E5%A4%9A%E9%87%8D%E8%B5%8B%E5%80%BC">2.4.1 多重赋值</a></li>
<li><a href="#242-%E5%8F%AF%E8%B5%8B%E5%80%BC%E6%80%A7">2.4.2 可赋值性</a></li>
</ul>
</li>
<li><a href="#25-%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E">2.5 类型声明</a></li>
<li><a href="#26-%E5%8C%85%E5%92%8C%E6%96%87%E4%BB%B6">2.6 包和文件</a></li>
<li><a href="#27-%E4%BD%9C%E7%94%A8%E5%9F%9F">2.7 作用域</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC3%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE">第3章 基本数据</a>
<ul>
<li><a href="#31-%E6%95%B4%E6%95%B0">3.1 整数</a></li>
<li><a href="#32-%E6%B5%AE%E7%82%B9%E6%95%B0">3.2 浮点数</a></li>
<li><a href="#33-%E5%A4%8D%E6%95%B0">3.3 复数</a></li>
<li><a href="#34-%E5%B8%83%E5%B0%94%E5%80%BC">3.4 布尔值</a></li>
<li><a href="#35-%E5%AD%97%E7%AC%A6%E4%B8%B2">3.5 字符串</a>
<ul>
<li><a href="#351-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F">3.5.1 字符串字面量</a></li>
<li><a href="#352-unicode">3.5.2 Unicode</a></li>
<li><a href="#353-utf-8">3.5.3 UTF-8</a></li>
<li><a href="#354-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E8%8A%82-slice">3.5.4 字符串和字节 slice</a></li>
<li><a href="#355-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E5%AD%97%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2">3.5.5 字符串和数字的相互转换</a></li>
</ul>
</li>
<li><a href="#36-%E5%B8%B8%E9%87%8F">3.6 常量</a>
<ul>
<li><a href="#361-%E5%B8%B8%E9%87%8F%E7%94%9F%E6%88%90%E5%99%A8-iota">3.6.1 常量生成器 iota</a></li>
<li><a href="#362-%E6%97%A0%E7%B1%BB%E5%9E%8B%E5%B8%B8%E9%87%8F">3.6.2 无类型常量</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%AC%AC4%E7%AB%A0-%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">第4章 复合数据类型</a>
<ul>
<li><a href="#41-%E6%95%B0%E7%BB%84">4.1 数组</a></li>
<li><a href="#42-slice">4.2 slice</a>
<ul>
<li><a href="#421-append-%E5%87%BD%E6%95%B0">4.2.1 append 函数</a></li>
<li><a href="#422-slice-%E5%B0%B1%E5%9C%B0%E4%BF%AE%E6%94%B9">4.2.2 slice 就地修改</a></li>
</ul>
</li>
<li><a href="#43-map">4.3 map</a></li>
<li><a href="#44-%E7%BB%93%E6%9E%84%E4%BD%93">4.4 结构体</a>
<ul>
<li><a href="#441-%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E9%9D%A2%E9%87%8F">4.4.1 结构体字面量</a></li>
<li><a href="#442-%E7%BB%93%E6%9E%84%E4%BD%93%E6%AF%94%E8%BE%83">4.4.2 结构体比较</a></li>
<li><a href="#443-%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%A5%97%E5%92%8C%E5%8C%BF%E5%90%8D%E6%88%90%E5%91%98">4.4.3 结构体嵌套和匿名成员</a></li>
</ul>
</li>
<li><a href="#45-json">4.5 JSON</a></li>
<li><a href="#46-%E6%96%87%E6%9C%AC%E5%92%8Chtml%E6%A8%A1%E6%9D%BF">4.6 文本和HTML模板</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC5%E7%AB%A0-%E5%87%BD%E6%95%B0">第5章 函数</a>
<ul>
<li><a href="#51-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E">5.1 函数声明</a></li>
<li><a href="#52-%E9%80%92%E5%BD%92">5.2 递归</a></li>
<li><a href="#53-%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC">5.3 多返回值</a></li>
<li><a href="#54-%E9%94%99%E8%AF%AF">5.4 错误</a>
<ul>
<li><a href="#541-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5">5.4.1 错误处理策略</a></li>
<li><a href="#542-%E6%96%87%E4%BB%B6%E7%BB%93%E6%9D%9F%E6%A0%87%E8%AF%86">5.4.2 文件结束标识</a></li>
</ul>
</li>
<li><a href="#55-%E5%87%BD%E6%95%B0%E5%8F%98%E9%87%8F">5.5 函数变量</a></li>
<li><a href="#56-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0">5.6 匿名函数</a></li>
<li><a href="#57-%E5%8F%98%E9%95%BF%E5%87%BD%E6%95%B0">5.7 变长函数</a></li>
<li><a href="#58-%E5%BB%B6%E8%BF%9F%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">5.8 延迟函数调用</a></li>
<li><a href="#59-%E5%AE%95%E6%9C%BA">5.9 宕机</a></li>
<li><a href="#510-%E6%81%A2%E5%A4%8D">5.10 恢复</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC6%E7%AB%A0-%E6%96%B9%E6%B3%95">第6章 方法</a>
<ul>
<li><a href="#61-%E6%96%B9%E6%B3%95%E5%A3%B0%E6%98%8E">6.1 方法声明</a></li>
<li><a href="#62-%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85%E7%9A%84%E6%96%B9%E6%B3%95">6.2 指针接收者的方法</a></li>
<li><a href="#63-%E9%80%9A%E8%BF%87%E6%8E%A5%E5%8F%A3%E6%8F%90%E5%86%85%E5%B5%8C%E7%BB%84%E6%88%90%E7%B1%BB%E5%9E%8B">6.3 通过接口提内嵌组成类型</a></li>
<li><a href="#64-%E6%96%B9%E6%B3%95%E5%8F%98%E9%87%8F%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F">6.4 方法变量与表达式</a></li>
<li><a href="#65-%E7%A4%BA%E4%BE%8B%E4%BD%8D%E5%90%91%E9%87%8F">6.5 示例：位向量</a></li>
<li><a href="#66-%E5%B0%81%E8%A3%85">6.6 封装</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC7%E7%AB%A0-%E6%8E%A5%E5%8F%A3">第7章 接口</a>
<ul>
<li><a href="#71-%E6%8E%A5%E5%8F%A3%E5%8D%B3%E7%BA%A6%E5%AE%9A">7.1 接口即约定</a></li>
<li><a href="#72-%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B">7.2 接口类型</a></li>
<li><a href="#73-%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3">7.3 实现接口</a></li>
<li><a href="#74-%E4%BD%BF%E7%94%A8-flagvalue-%E6%9D%A5%E8%A7%A3%E6%9E%90%E5%8F%82%E6%95%B0">7.4 使用 flag.Value 来解析参数</a></li>
<li><a href="#75-%E6%8E%A5%E5%8F%A3%E5%80%BC">7.5 接口值</a></li>
<li><a href="#76-%E4%BD%BF%E7%94%A8-sortinterface-%E6%9D%A5%E6%8E%92%E5%BA%8F">7.6 使用 sort.Interface 来排序</a></li>
<li><a href="#77-httphandler-%E6%8E%A5%E5%8F%A3">7.7 http.Handler 接口</a></li>
<li><a href="#78-error-%E6%8E%A5%E5%8F%A3">7.8 error 接口</a></li>
<li><a href="#79-%E7%A4%BA%E4%BE%8B%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E5%99%A8">7.9 示例：表达式求值器</a></li>
<li><a href="#710-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80">7.10 类型断言</a></li>
<li><a href="#711-%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E6%9D%A5%E8%AF%86%E5%88%AB%E9%94%99%E8%AF%AF">7.11 使用类型断言来识别错误</a></li>
<li><a href="#712-%E9%80%9A%E8%BF%87%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E6%9D%A5%E6%9F%A5%E8%AF%A2%E7%89%B9%E6%80%A7">7.12 通过接口类型断言来查询特性</a></li>
<li><a href="#713-%E7%B1%BB%E5%9E%8B%E5%88%86%E6%94%AF">7.13 类型分支</a></li>
<li><a href="#714-%E7%A4%BA%E4%BE%8B%E5%9F%BA%E4%BA%8E%E6%A0%87%E8%AE%B0%E7%9A%84xml%E8%A7%A3%E6%9E%90">7.14 示例：基于标记的XML解析</a></li>
<li><a href="#715-%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE">7.15 一些建议</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC8%E7%AB%A0-goroutine%E5%92%8C%E9%80%9A%E9%81%93">第8章 goroutine和通道</a>
<ul>
<li><a href="#81-goroutine">8.1 goroutine</a></li>
<li><a href="#82-%E7%A4%BA%E4%BE%8B%E5%B9%B6%E5%8F%91%E6%97%B6%E9%92%9F%E6%9C%8D%E5%8A%A1%E5%99%A8">8.2 示例：并发时钟服务器</a></li>
<li><a href="#83-%E7%A4%BA%E4%BE%8B%E5%B9%B6%E5%8F%91%E5%9B%9E%E5%A3%B0%E6%9C%8D%E5%8A%A1%E5%99%A8">8.3 示例：并发回声服务器</a></li>
<li><a href="#84-%E9%80%9A%E9%81%93">8.4 通道</a>
<ul>
<li><a href="#841-%E6%97%A0%E7%BC%93%E5%86%B2%E9%80%9A%E9%81%93">8.4.1 无缓冲通道</a></li>
<li><a href="#842-%E7%AE%A1%E9%81%93">8.4.2 管道</a></li>
<li><a href="#843-%E5%8D%95%E5%90%91%E9%80%9A%E9%81%93%E7%B1%BB%E5%9E%8B">8.4.3 单向通道类型</a></li>
<li><a href="#844-%E7%BC%93%E5%86%B2%E9%80%9A%E9%81%93">8.4.4 缓冲通道</a></li>
</ul>
</li>
<li><a href="#85-%E5%B9%B6%E8%A1%8C%E5%BE%AA%E7%8E%AF">8.5 并行循环</a></li>
<li><a href="#86-%E7%A4%BA%E4%BE%8B%E5%B9%B6%E5%8F%91%E7%9A%84web%E7%88%AC%E8%99%AB">8.6 示例：并发的Web爬虫</a></li>
<li><a href="#87-%E4%BD%BF%E7%94%A8select%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">8.7 使用select多路复用</a></li>
<li><a href="#88-%E7%A4%BA%E4%BE%8B%E5%B9%B6%E5%8F%91%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86">8.8 示例：并发目录遍历</a></li>
<li><a href="#89-%E5%8F%96%E6%B6%88">8.9 取消</a></li>
<li><a href="#810-%E7%A4%BA%E4%BE%8B%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8">8.10 示例：聊天服务器</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC9%E7%AB%A0-%E4%BD%BF%E7%94%A8%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91">第9章 使用共享变量实现并发</a>
<ul>
<li><a href="#91-%E7%AB%9E%E6%80%81">9.1 竞态</a></li>
<li><a href="#92-%E4%BA%92%E6%96%A5%E9%94%81-syncmutex">9.2 互斥锁 sync.Mutex</a></li>
<li><a href="#93-%E8%AF%BB%E5%86%99%E4%BA%92%E6%96%A5%E9%94%81syncrwmutex">9.3 读写互斥锁：sync.RWMutex</a></li>
<li><a href="#94-%E5%86%85%E5%AD%98%E5%90%8C%E6%AD%A5">9.4 内存同步</a></li>
<li><a href="#95-%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E5%8C%96synconce">9.5 延迟初始化：sync.Once</a></li>
<li><a href="#96-%E7%AB%9E%E6%80%81%E6%A3%80%E6%B5%8B%E5%99%A8">9.6 竞态检测器</a></li>
<li><a href="#97-%E7%A4%BA%E4%BE%8B%E5%B9%B6%E5%8F%91%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%BC%93%E5%AD%98">9.7 示例：并发非阻塞缓存</a></li>
<li><a href="#98-goroutine-%E4%B8%8E%E7%BA%BF%E7%A8%8B">9.8 goroutine 与线程</a>
<ul>
<li><a href="#981-%E5%8F%AF%E5%A2%9E%E9%95%BF%E7%9A%84%E6%A0%88">9.8.1 可增长的栈</a></li>
<li><a href="#982-goroutine-%E8%B0%83%E5%BA%A6">9.8.2 goroutine 调度</a></li>
<li><a href="#983-gomaxprocs">9.8.3 GOMAXPROCS</a></li>
<li><a href="#984-goroutine-%E6%B2%A1%E6%9C%89%E6%A0%87%E8%AF%86">9.8.4 goroutine 没有标识</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%AC%AC10%E7%AB%A0-%E5%8C%85%E5%92%8C-go-%E5%B7%A5%E5%85%B7">第10章 包和 go 工具</a>
<ul>
<li><a href="#101-%E5%BC%95%E8%A8%80">10.1 引言</a></li>
<li><a href="#102-%E5%AF%BC%E5%85%A5%E8%B7%AF%E5%BE%84">10.2 导入路径</a></li>
<li><a href="#103-%E5%8C%85%E7%9A%84%E5%A3%B0%E6%98%8E">10.3 包的声明</a></li>
<li><a href="#104-%E5%AF%BC%E5%85%A5%E5%A3%B0%E6%98%8E">10.4 导入声明</a></li>
<li><a href="#105-%E7%A9%BA%E5%AF%BC%E5%85%A5">10.5 空导入</a></li>
<li><a href="#106-%E5%8C%85%E5%8F%8A%E5%85%B6%E5%91%BD%E5%90%8D">10.6 包及其命名</a></li>
<li><a href="#107-go-%E5%B7%A5%E5%85%B7">10.7 go 工具</a>
<ul>
<li><a href="#1071-%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E7%9A%84%E7%BB%84%E7%BB%87">10.7.1 工作空间的组织</a></li>
<li><a href="#1072-%E5%8C%85%E7%9A%84%E4%B8%8B%E8%BD%BD">10.7.2 包的下载</a></li>
<li><a href="#1073-%E5%8C%85%E7%9A%84%E6%9E%84%E5%BB%BA">10.7.3 包的构建</a></li>
<li><a href="#1074-%E5%8C%85%E7%9A%84%E6%96%87%E6%A1%A3%E5%8C%96">10.7.4 包的文档化</a></li>
<li><a href="#1075-%E5%86%85%E9%83%A8%E5%8C%85">10.7.5 内部包</a></li>
<li><a href="#1076-%E5%8C%85%E7%9A%84%E6%9F%A5%E8%AF%A2">10.7.6 包的查询</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%AC%AC11%E7%AB%A0-%E6%B5%8B%E8%AF%95">第11章 测试</a>
<ul>
<li><a href="#111-go-test-%E5%B7%A5%E5%85%B7">11.1 go test 工具</a></li>
<li><a href="#112-test-%E5%87%BD%E6%95%B0">11.2 Test 函数</a>
<ul>
<li><a href="#1121-%E9%9A%8F%E6%9C%BA%E6%B5%8B%E8%AF%95">11.2.1 随机测试</a></li>
<li><a href="#1122-%E6%B5%8B%E8%AF%95%E5%91%BD%E4%BB%A4">11.2.2 测试命令</a></li>
<li><a href="#1123-%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95">11.2.3 白盒测试</a></li>
<li><a href="#1124-%E5%A4%96%E9%83%A8%E6%B5%8B%E8%AF%95%E5%8C%85">11.2.4 外部测试包</a></li>
<li><a href="#1125-%E7%BC%96%E5%86%99%E6%9C%89%E6%95%88%E6%B5%8B%E8%AF%95">11.2.5 编写有效测试</a></li>
<li><a href="#1126-%E9%81%BF%E5%85%8D%E8%84%86%E5%BC%B1%E7%9A%84%E6%B5%8B%E8%AF%95">11.2.6 避免脆弱的测试</a></li>
</ul>
</li>
<li><a href="#113-%E8%A6%86%E7%9B%96%E7%8E%87">11.3 覆盖率</a></li>
<li><a href="#114-benchmark-%E5%87%BD%E6%95%B0">11.4 Benchmark 函数</a></li>
<li><a href="#115-%E6%80%A7%E8%83%BD%E5%88%A8%E6%9E%90">11.5 性能刨析</a></li>
<li><a href="#116-example-%E5%87%BD%E6%95%B0">11.6 Example 函数</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC12%E7%AB%A0-%E5%8F%8D%E5%B0%84">第12章 反射</a>
<ul>
<li><a href="#121-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84">12.1 为什么使用反射</a></li>
<li><a href="#122-reflecttype-%E5%92%8C-reflectvalue">12.2 reflect.Type 和 reflect.Value</a></li>
<li><a href="#123-display-%E4%B8%80%E4%B8%AA%E9%80%92%E5%BD%92%E7%9A%84%E5%80%BC%E6%98%BE%E7%A4%BA%E5%99%A8">12.3 Display: 一个递归的值显示器</a></li>
<li><a href="#124-%E7%A4%BA%E4%BE%8B-%E7%BC%96%E7%A0%81s%E8%A1%A8%E8%BE%BE%E5%BC%8F">12.4 示例: 编码S表达式</a></li>
<li><a href="#125-%E4%BD%BF%E7%94%A8-reflectvalue-%E6%9D%A5%E8%AE%BE%E7%BD%AE%E5%80%BC">12.5 使用 reflect.Value 来设置值</a></li>
<li><a href="#126-%E7%A4%BA%E4%BE%8B%E8%A7%A3%E7%A0%81s%E8%A1%A8%E8%BE%BE%E5%BC%8F">12.6 示例：解码S表达式</a></li>
<li><a href="#127-%E8%AE%BF%E9%97%AE%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E6%AE%B5%E6%A0%87%E7%AD%BE">12.7 访问结构体字段标签</a></li>
<li><a href="#128-%E6%98%BE%E7%A4%BA%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95">12.8 显示类型的方法</a></li>
<li><a href="#129-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">12.9 注意事项</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC13%E7%AB%A0-%E4%BD%8E%E7%BA%A7%E7%BC%96%E7%A8%8B">第13章 低级编程</a>
<ul>
<li><a href="#131-unsafesizeof-alignof-%E5%92%8C-offsetof">13.1 unsafe.Sizeof、Alignof 和 Offsetof</a></li>
<li><a href="#132-unsafepointer">13.2 unsafe.Pointer</a></li>
<li><a href="#133-%E7%A4%BA%E4%BE%8B%E6%B7%B1%E5%BA%A6%E7%9B%B8%E7%AD%89">13.3 示例：深度相等</a></li>
<li><a href="#134-%E4%BD%BF%E7%94%A8cgo%E8%B0%83%E7%94%A8c%E4%BB%A3%E7%A0%81">13.4 使用cgo调用C代码</a></li>
<li><a href="#135-%E5%85%B3%E4%BA%8E%E5%AE%89%E5%85%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">13.5 关于安全的注意事项</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
          
          <hr />
          <p class="next-post">下一篇：
            <a href="https://jinvic.github.io/post/[Graduation-Design]-Design-and-Implementation-of-an-Analysis-and-Decision-System-for-Online-Purchasing-of-Goods/">
              <span class="post-title">
                【毕设】网络代购货品分析与决策系统的设计与实现&rarr;
              </span>
            </a>
          </p>
          
          <div class="comment" style="text-align: center;">
            

            
            
            
            <!-- <script src='https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js'></script> -->
<script src='//unpkg.com/@waline/client@v2/dist/waline.js'></script>
<link href='//unpkg.com/@waline/client@v2/dist/waline.css' rel='stylesheet' />

<!-- <style>
	div#vcomments{
		width:100%;
		max-width: 1000px;
		padding: 2.5%
	}
</style> -->

<!--  -->

	<div id="wcomments"></div>

<script>
	// new Valine({
	Waline.init({
		el: '#wcomments',
		serverURL: 'personal-blog-comments.vercel.app',
		login: 'enable',
		wordLimit: 300,
		pageSize: 10,
		reaction: true,
		
	});
</script>

            
          </div>
        </div>
      </div>
  </article>
  <!-- Footer -->
  <footer>
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto">
          <ul class="list-inline text-center">
            
            
            <li class="list-inline-item">
              <a href="https://github.com/Jinvic" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
            
              
            
              
            
              
            
              
            
              
            
              
            
              
              <!-- <li class="list-inline-item">
              <a href="https://jinvic.github.io/atom.xml" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
                </span>
              </a>
              </li> -->
          </ul>
          <p class="copyright text-muted">Copyright &copy;<span>Jinvic&#39;s Blog</span><br><a href="https://github.com/getgridea/gridea" class="Themeinfo">Powered by Gridea</a></p>
        </div>
      </div>
    </div>
   </footer>
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.bootcss.com/twitter-bootstrap/4.3.1/js/bootstrap.bundle.min.js"></script>
  <!-- <script src="https://jinvic.github.io/media/scripts/bootstrap.bundle.min.js"></script> -->
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.jsdelivr.net/gh/Alanrk/clean-cdn@1.0/scripts/clean-blog.min.js"></script>
  <!-- <script src="https://jinvic.github.io/media/scripts/clean-blog.min.js"></script> -->
  <script src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>
  <style type="text/css">a.back_to_top{text-decoration:none;position:fixed;bottom:40px;right:30px;background:#f0f0f0;height:40px;width:40px;border-radius:50%;line-height:36px;font-size:18px;text-align:center;transition-duration:.5s;transition-propety:background-color;display:none}a.back_to_top span{color:#888}a.back_to_top:hover{cursor:pointer;background:#dfdfdf}a.back_to_top:hover span{color:#555}@media print,screen and(max-width:580px){.back_to_top{display:none!important}}</style>
<a id="back_to_top" href="#" class="back_to_top">
  <span>▲</span></a>
<script>$(document).ready((function(_this) {
    return function() {
      var bt;
      bt = $('#back_to_top');
      if ($(document).width() > 480) {
        $(window).scroll(function() {
          var st;
          st = $(window).scrollTop();
          if (st > 30) {
            return bt.css('display', 'block')
          } else {
            return bt.css('display', 'none')
          }
        });
        return bt.click(function() {
          $('body,html').animate({
            scrollTop: 0
          },
          800);
          return false
        })
      }
    }
  })(this));</script>
  
  <div id="landlord-parent">
    <div id="landlord">
        <div class="message" style="opacity:0"></div>
        <canvas id="live2d" width="200" height="300" class="live2d"></canvas>
    </div>
</div>

<script type="text/javascript">
    if (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent)) {
        //移动端
        console.log("------ 移动端");
    } else {
        console.log("------ PC端 " + navigator.userAgent);

        addScript("https://cdn.jsdelivr.net/gh/850552586/ericamcdn@0.1/js/live2d.js", () => {
            // 加载完成后再loadlive2d
            loadlive2d("live2d", "https://jinvic.github.io/media/live2d/assets/koharu.model.json");
        });

        var home_Path = "https://jinvic.github.io/";
        addScript("https://jinvic.github.io/media/live2d/js/message.js", () => { });
    }

    // 插入js文件，完成后callback
    function addScript(jsfile, callback) {
        var landlord_parent = document.getElementById("landlord-parent");
        var script = document.createElement("script");
        script.type = "text/javascript";
        script.src = jsfile;
        landlord_parent.appendChild(script);
        script.onload = script.onreadystatechange = function () {
            if (!this.readyState || this.readyState === "loaded" || this.readyState === "complete") {
                script.onload = script.onreadystatechange = null;
                if (callback && typeof callback == "function") {
                    callback(); //window[callback]();如果传递字符串过来 调用window['函数名']() 调用方法
                }
            }
        };
    }
</script>
  
  <script src="https://jinvic.github.io/media/scripts/tocScript.js"></script>
</body>

</html>